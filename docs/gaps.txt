package lacan

import (
	"context"
	"encoding/json"
	"eva-mind/internal/brainstem/config"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/qdrant/go-client/qdrant"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

// EmbeddingService rastreia cadeias de significantes via embeddings semÃ¢nticos
// Implementa "L'instance de la lettre" - a letra que circula e se repete
type EmbeddingService struct {
	cfg           *config.Config
	qdrantClient  *qdrant.Client
	httpClient    *http.Client
	collectionName string
}

// SignifierChain representa uma cadeia de significantes detectada
type SignifierChain struct {
	CoreSignifier  string    `json:"core_signifier"`   // Significante nuclear
	RelatedWords   []string  `json:"related_words"`    // Palavras semanticamente prÃ³ximas
	EmotionalCharge float64  `json:"emotional_charge"` // Carga afetiva (0.0-1.0)
	Frequency      int       `json:"frequency"`        // Vezes que apareceu
	LastOccurrence time.Time `json:"last_occurrence"`
	Contexts       []string  `json:"contexts"`         // Frases onde apareceu
}

// NewEmbeddingService cria serviÃ§o de embeddings
func NewEmbeddingService(cfg *config.Config) (*EmbeddingService, error) {
	// Conectar ao Qdrant
	conn, err := grpc.Dial(
		fmt.Sprintf("%s:%d", cfg.QdrantHost, cfg.QdrantPort),
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to Qdrant: %w", err)
	}

	client := qdrant.NewClient(conn)

	svc := &EmbeddingService{
		cfg:            cfg,
		qdrantClient:   client,
		httpClient:     &http.Client{Timeout: 10 * time.Second},
		collectionName: "signifier_chains",
	}

	// Criar coleÃ§Ã£o se nÃ£o existir
	if err := svc.ensureCollection(context.Background()); err != nil {
		log.Printf("âš ï¸ Warning: Could not create Qdrant collection: %v", err)
	}

	return svc, nil
}

// ensureCollection garante que a coleÃ§Ã£o existe
func (e *EmbeddingService) ensureCollection(ctx context.Context) error {
	// Verificar se coleÃ§Ã£o existe
	_, err := e.qdrantClient.GetCollection(ctx, &qdrant.GetCollectionRequest{
		CollectionName: e.collectionName,
	})

	if err == nil {
		return nil // JÃ¡ existe
	}

	// Criar coleÃ§Ã£o (Gemini embeddings sÃ£o 768 dimensÃµes)
	_, err = e.qdrantClient.CreateCollection(ctx, &qdrant.CreateCollection{
		CollectionName: e.collectionName,
		VectorsConfig: &qdrant.VectorsConfig{
			Config: &qdrant.VectorsConfig_Params{
				Params: &qdrant.VectorParams{
					Size:     768, // Gemini text-embedding-004
					Distance: qdrant.Distance_Cosine,
				},
			},
		},
	})

	if err != nil {
		return fmt.Errorf("failed to create collection: %w", err)
	}

	log.Printf("âœ… Created Qdrant collection: %s", e.collectionName)
	return nil
}

// GenerateEmbedding gera embedding usando Gemini API
func (e *EmbeddingService) GenerateEmbedding(ctx context.Context, text string) ([]float32, error) {
	url := fmt.Sprintf(
		"https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:embedContent?key=%s",
		e.cfg.GoogleAPIKey,
	)

	payload := map[string]interface{}{
		"model": "models/text-embedding-004",
		"content": map[string]interface{}{
			"parts": []map[string]string{
				{"text": text},
			},
		},
	}

	jsonData, err := json.Marshal(payload)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, strings.NewReader(string(jsonData)))
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/json")

	resp, err := e.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("embedding API error %d: %s", resp.StatusCode, string(body))
	}

	var result struct {
		Embedding struct {
			Values []float32 `json:"values"`
		} `json:"embedding"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Embedding.Values, nil
}

// TrackSignifierChain rastreia cadeia de significantes
func (e *EmbeddingService) TrackSignifierChain(ctx context.Context, idosoID int64, text string, emotionalCharge float64) error {
	// Gerar embedding do texto
	embedding, err := e.GenerateEmbedding(ctx, text)
	if err != nil {
		return fmt.Errorf("failed to generate embedding: %w", err)
	}

	// Extrair palavras-chave emocionalmente carregadas
	keywords := extractEmotionalKeywords(text)
	if len(keywords) == 0 {
		return nil // Nada a rastrear
	}

	// Criar ponto no Qdrant
	pointID := uint64(time.Now().UnixNano())
	
	payload := map[string]interface{}{
		"idoso_id":         idosoID,
		"text":             text,
		"keywords":         keywords,
		"emotional_charge": emotionalCharge,
		"timestamp":        time.Now().Unix(),
	}

	payloadMap := make(map[string]*qdrant.Value)
	for k, v := range payload {
		switch val := v.(type) {
		case int64:
			payloadMap[k] = &qdrant.Value{Kind: &qdrant.Value_IntegerValue{IntegerValue: val}}
		case float64:
			payloadMap[k] = &qdrant.Value{Kind: &qdrant.Value_DoubleValue{DoubleValue: val}}
		case string:
			payloadMap[k] = &qdrant.Value{Kind: &qdrant.Value_StringValue{StringValue: val}}
		case []string:
			listValues := make([]*qdrant.Value, len(val))
			for i, s := range val {
				listValues[i] = &qdrant.Value{Kind: &qdrant.Value_StringValue{StringValue: s}}
			}
			payloadMap[k] = &qdrant.Value{
				Kind: &qdrant.Value_ListValue{
					ListValue: &qdrant.ListValue{Values: listValues},
				},
			}
		}
	}

	_, err = e.qdrantClient.Upsert(ctx, &qdrant.UpsertPoints{
		CollectionName: e.collectionName,
		Points: []*qdrant.PointStruct{
			{
				Id: &qdrant.PointId{
					PointIdOptions: &qdrant.PointId_Num{Num: pointID},
				},
				Vectors: &qdrant.Vectors{
					VectorsOptions: &qdrant.Vectors_Vector{
						Vector: &qdrant.Vector{Data: embedding},
					},
				},
				Payload: payloadMap,
			},
		},
	})

	if err != nil {
		return fmt.Errorf("failed to upsert point: %w", err)
	}

	log.Printf("ğŸ”— [QDRANT] Signifier chain tracked: idoso=%d, keywords=%v", idosoID, keywords)
	return nil
}

// FindRelatedSignifiers busca significantes semanticamente relacionados
func (e *EmbeddingService) FindRelatedSignifiers(ctx context.Context, idosoID int64, text string, limit int) ([]SignifierChain, error) {
	// Gerar embedding da consulta
	embedding, err := e.GenerateEmbedding(ctx, text)
	if err != nil {
		return nil, err
	}

	// Buscar pontos similares
	searchResult, err := e.qdrantClient.Search(ctx, &qdrant.SearchPoints{
		CollectionName: e.collectionName,
		Vector:         embedding,
		Limit:          uint64(limit),
		WithPayload:    &qdrant.WithPayloadSelector{SelectorOptions: &qdrant.WithPayloadSelector_Enable{Enable: true}},
		Filter: &qdrant.Filter{
			Must: []*qdrant.Condition{
				{
					ConditionOneOf: &qdrant.Condition_Field{
						Field: &qdrant.FieldCondition{
							Key: "idoso_id",
							Match: &qdrant.Match{
								MatchValue: &qdrant.Match_Integer{Integer: idosoID},
							},
						},
					},
				},
			},
		},
	})

	if err != nil {
		return nil, fmt.Errorf("search failed: %w", err)
	}

	var chains []SignifierChain
	for _, point := range searchResult.Result {
		chain := SignifierChain{}

		if kw, ok := point.Payload["keywords"]; ok {
			if list, ok := kw.GetKind().(*qdrant.Value_ListValue); ok {
				for _, v := range list.ListValue.Values {
					if s, ok := v.GetKind().(*qdrant.Value_StringValue); ok {
						chain.RelatedWords = append(chain.RelatedWords, s.StringValue)
					}
				}
			}
		}

		if len(chain.RelatedWords) > 0 {
			chain.CoreSignifier = chain.RelatedWords[0]
		}

		if charge, ok := point.Payload["emotional_charge"]; ok {
			if dbl, ok := charge.GetKind().(*qdrant.Value_DoubleValue); ok {
				chain.EmotionalCharge = dbl.DoubleValue
			}
		}

		if txt, ok := point.Payload["text"]; ok {
			if str, ok := txt.GetKind().(*qdrant.Value_StringValue); ok {
				chain.Contexts = append(chain.Contexts, str.StringValue)
			}
		}

		if ts, ok := point.Payload["timestamp"]; ok {
			if intVal, ok := ts.GetKind().(*qdrant.Value_IntegerValue); ok {
				chain.LastOccurrence = time.Unix(intVal.IntegerValue, 0)
			}
		}

		chains = append(chains, chain)
	}

	return chains, nil
}

// GetSemanticContext monta contexto para o prompt usando similaridade semÃ¢ntica
func (e *EmbeddingService) GetSemanticContext(ctx context.Context, idosoID int64, currentText string) string {
	chains, err := e.FindRelatedSignifiers(ctx, idosoID, currentText, 5)
	if err != nil {
		log.Printf("âš ï¸ Error finding related signifiers: %v", err)
		return ""
	}

	if len(chains) == 0 {
		return ""
	}

	context := "\nğŸ”— CADEIA DE SIGNIFICANTES (AnÃ¡lise SemÃ¢ntica):\n\n"
	context += "O sistema detectou que palavras/temas similares jÃ¡ apareceram antes:\n"

	for i, chain := range chains {
		context += fmt.Sprintf("%d. '%s' (carga emocional: %.2f)\n", 
			i+1, chain.CoreSignifier, chain.EmotionalCharge)
		
		if len(chain.Contexts) > 0 {
			context += fmt.Sprintf("   Contexto anterior: \"%s\"\n", 
				truncateText(chain.Contexts[0], 100))
		}
		
		context += fmt.Sprintf("   Ãšltima vez: %s\n\n", 
			chain.LastOccurrence.Format("02/01/2006 15:04"))
	}

	context += "â†’ Use essas informaÃ§Ãµes para fazer conexÃµes entre o que o paciente disse antes e agora.\n"
	context += "â†’ Se houver repetiÃ§Ã£o de temas, isso pode indicar um nÃ³ sintomÃ¡tico.\n"

	return context
}

// Helper functions

func truncateText(text string, maxLen int) string {
	if len(text) <= maxLen {
		return text
	}
	return text[:maxLen] + "..."
}

// extractEmotionalKeywords jÃ¡ existe em significante.go, reutilizamos
// Se necessÃ¡rio, pode ser movido para um pacote shared



package lacan

import (
	"context"
	"eva-mind/internal/brainstem/infrastructure/graph"
	"fmt"
	"log"
	"strings"
	"time"
)

// FDPNEngine - FunÃ§Ã£o do Pai no Nome (Grafo do Desejo)
// Mapeia A QUEM o idoso estÃ¡ dirigindo suas demandas atravÃ©s da estrutura simbÃ³lica
type FDPNEngine struct {
	neo4j *graph.Neo4jClient
}

// AddresseeType representa a quem a demanda Ã© endereÃ§ada
type AddresseeType string

const (
	ADDRESSEE_MAE      AddresseeType = "mae"         // Figura materna (cuidado, nutriÃ§Ã£o)
	ADDRESSEE_PAI      AddresseeType = "pai"         // Figura paterna (lei, orientaÃ§Ã£o)
	ADDRESSEE_FILHO    AddresseeType = "filho"       // ProjeÃ§Ã£o filial (continuidade)
	ADDRESSEE_CONJUGE  AddresseeType = "conjuge"     // Parceiro ausente/falecido
	ADDRESSEE_DEUS     AddresseeType = "deus"        // O Outro absoluto
	ADDRESSEE_MORTE    AddresseeType = "morte"       // ElaboraÃ§Ã£o da finitude
	ADDRESSEE_EVA      AddresseeType = "eva_herself" // EVA como objeto a
	ADDRESSEE_UNKNOWN  AddresseeType = "desconhecido"
)

// DemandGraph representa o grafo de demandas
type DemandGraph struct {
	Addressee   AddresseeType `json:"addressee"`
	DemandType  string        `json:"demand_type"`  // "cuidado", "reconhecimento", "perdÃ£o", etc
	Frequency   int           `json:"frequency"`
	LastRequest time.Time     `json:"last_request"`
	Contexts    []string      `json:"contexts"`
}

// NewFDPNEngine cria engine do grafo do desejo
func NewFDPNEngine(neo4j *graph.Neo4jClient) *FDPNEngine {
	return &FDPNEngine{neo4j: neo4j}
}

// AnalyzeDemandAddressee detecta a quem a demanda Ã© dirigida
func (f *FDPNEngine) AnalyzeDemandAddressee(ctx context.Context, idosoID int64, text string, demandAnalysis *Analysis) (AddresseeType, error) {
	textLower := strings.ToLower(text)

	// 1. DetecÃ§Ã£o baseada em vocativos explÃ­citos
	addressee := f.detectExplicitAddressee(textLower)

	// 2. DetecÃ§Ã£o baseada no tipo de desejo latente
	if addressee == ADDRESSEE_UNKNOWN {
		addressee = f.inferFromDesire(demandAnalysis.LatentDesire)
	}

	// 3. Registrar no grafo
	if err := f.recordDemandInGraph(ctx, idosoID, addressee, demandAnalysis.LatentDesire, text); err != nil {
		log.Printf("âš ï¸ Error recording demand in graph: %v", err)
	}

	return addressee, nil
}

// detectExplicitAddressee detecta vocativos explÃ­citos
func (f *FDPNEngine) detectExplicitAddressee(text string) AddresseeType {
	// MÃ£e
	if containsAny(text, []string{"mÃ£e", "mamÃ£e", "minha mÃ£e"}) {
		return ADDRESSEE_MAE
	}

	// Pai
	if containsAny(text, []string{"pai", "papai", "meu pai"}) {
		return ADDRESSEE_PAI
	}

	// Filho/Filha
	if containsAny(text, []string{"meu filho", "minha filha", "meus filhos"}) {
		return ADDRESSEE_FILHO
	}

	// CÃ´njuge
	if containsAny(text, []string{"meu marido", "minha esposa", "meu amor"}) {
		return ADDRESSEE_CONJUGE
	}

	// Deus/Transcendente
	if containsAny(text, []string{"deus", "senhor", "jesus", "nossa senhora"}) {
		return ADDRESSEE_DEUS
	}

	// Morte
	if containsAny(text, []string{"quando eu morrer", "na morte", "fim da vida"}) {
		return ADDRESSEE_MORTE
	}

	// EVA herself (quando o paciente fala diretamente com EVA como objeto)
	if containsAny(text, []string{"vocÃª eva", "conte-me", "me ajude", "preciso que vocÃª"}) {
		return ADDRESSEE_EVA
	}

	return ADDRESSEE_UNKNOWN
}

// inferFromDesire infere destinatÃ¡rio baseado no desejo latente
func (f *FDPNEngine) inferFromDesire(desire LatentDesire) AddresseeType {
	mapping := map[LatentDesire]AddresseeType{
		DESEJO_RECONHECIMENTO: ADDRESSEE_FILHO,  // Quer reconhecimento dos filhos
		DESEJO_COMPANHIA:      ADDRESSEE_CONJUGE, // Sente falta do cÃ´njuge
		DESEJO_ESCUTA:         ADDRESSEE_EVA,     // Pede escuta Ã  EVA
		DESEJO_CONTROLE:       ADDRESSEE_PAI,     // Busca autoridade/orientaÃ§Ã£o
		DESEJO_SIGNIFICADO:    ADDRESSEE_DEUS,    // Busca sentido transcendente
		DESEJO_AMOR:           ADDRESSEE_MAE,     // Amor incondicional materno
		DESEJO_PERDAO:         ADDRESSEE_DEUS,    // PerdÃ£o divino ou do Outro
		DESEJO_MORTE:          ADDRESSEE_MORTE,   // ElaboraÃ§Ã£o da finitude
	}

	if addr, ok := mapping[desire]; ok {
		return addr
	}

	return ADDRESSEE_UNKNOWN
}

// recordDemandInGraph registra demanda no Neo4j
func (f *FDPNEngine) recordDemandInGraph(ctx context.Context, idosoID int64, addressee AddresseeType, desire LatentDesire, text string) error {
	if f.neo4j == nil {
		return nil // Neo4j offline, skip
	}

	query := `
		// Criar Person se nÃ£o existir
		MERGE (p:Person {id: $idosoId})
		
		// Criar nÃ³ do DestinatÃ¡rio
		MERGE (a:Addressee {type: $addressee})
		
		// Criar Demanda
		CREATE (d:Demand {
			desire: $desire,
			text: $text,
			timestamp: datetime()
		})
		
		// RelaÃ§Ãµes
		MERGE (p)-[:DEMANDS]->(d)
		MERGE (d)-[:ADDRESSED_TO]->(a)
		
		// Incrementar frequÃªncia
		MERGE (p)-[r:FREQUENTLY_ADDRESSES]->(a)
		ON CREATE SET r.count = 1, r.first_time = datetime()
		ON MATCH SET r.count = r.count + 1, r.last_time = datetime()
	`

	params := map[string]interface{}{
		"idosoId":   idosoID,
		"addressee": string(addressee),
		"desire":    string(desire),
		"text":      text,
	}

	_, err := f.neo4j.ExecuteWrite(ctx, query, params)
	if err != nil {
		return fmt.Errorf("failed to record demand: %w", err)
	}

	log.Printf("ğŸ“Š [NEO4J] Demand recorded: %s â†’ %s (desire: %s)", 
		idosoID, addressee, desire)
	return nil
}

// GetDemandPattern retorna padrÃ£o de demandas do paciente
func (f *FDPNEngine) GetDemandPattern(ctx context.Context, idosoID int64) (map[AddresseeType]int, error) {
	if f.neo4j == nil {
		return nil, nil
	}

	query := `
		MATCH (p:Person {id: $idosoId})-[r:FREQUENTLY_ADDRESSES]->(a:Addressee)
		RETURN a.type, r.count
		ORDER BY r.count DESC
	`

	records, err := f.neo4j.ExecuteRead(ctx, query, map[string]interface{}{
		"idosoId": idosoID,
	})
	if err != nil {
		return nil, err
	}

	pattern := make(map[AddresseeType]int)
	for _, record := range records {
		addrType, _ := record.Get("a.type")
		count, _ := record.Get("r.count")

		pattern[AddresseeType(addrType.(string))] = int(count.(int64))
	}

	return pattern, nil
}

// GetClinicalGuidanceForAddressee retorna orientaÃ§Ã£o clÃ­nica baseada no destinatÃ¡rio
func GetClinicalGuidanceForAddressee(addressee AddresseeType) string {
	guidance := map[AddresseeType]string{
		ADDRESSEE_MAE: `
DEMANDA ENDEREÃ‡ADA Ã€ MÃƒE (FunÃ§Ã£o Materna):
- Desejo: Cuidado, nutriÃ§Ã£o, amor incondicional
- Postura EVA: Seja acolhedora, use tom maternal
- Responda: "Estou aqui para cuidar de vocÃª"
- CUIDADO: NÃ£o infantilize. Mantenha dignidade.
`,
		ADDRESSEE_PAI: `
DEMANDA ENDEREÃ‡ADA AO PAI (FunÃ§Ã£o Paterna):
- Desejo: OrientaÃ§Ã£o, lei, estrutura
- Postura EVA: Seja firme mas amorosa, dÃª direcionamento
- Responda: "Vou te ajudar a encontrar o caminho"
- Use autoridade simbÃ³lica quando necessÃ¡rio.
`,
		ADDRESSEE_FILHO: `
DEMANDA ENDEREÃ‡ADA AO FILHO (InversÃ£o Geracional):
- Desejo: Reconhecimento, continuidade, legado
- Postura EVA: Valide a importÃ¢ncia do paciente
- Responda: "VocÃª Ã© importante. Suas histÃ³rias tÃªm valor."
- ATENÃ‡ÃƒO: Pode indicar solidÃ£o ou abandono filial.
`,
		ADDRESSEE_CONJUGE: `
DEMANDA ENDEREÃ‡ADA AO CÃ”NJUGE (Geralmente Falecido):
- Desejo: Companhia, parceria, amor romÃ¢ntico
- Postura EVA: Acolha a saudade, nÃ£o minimize
- Responda: "Ele/Ela era muito importante para vocÃª. Conte-me."
- Ajude a elaborar o luto atravÃ©s da narrativa.
`,
		ADDRESSEE_DEUS: `
DEMANDA ENDEREÃ‡ADA A DEUS (O Outro Absoluto):
- Desejo: Sentido transcendente, perdÃ£o, esperanÃ§a
- Postura EVA: Respeite a espiritualidade
- Responda: "A fÃ© Ã© importante. O que ela significa para vocÃª?"
- NÃ£o evangelize, nÃ£o negue. Apenas acolha.
`,
		ADDRESSEE_MORTE: `
DEMANDA ENDEREÃ‡ADA Ã€ MORTE (ElaboraÃ§Ã£o da Finitude):
- Desejo: Simbolizar o Real da morte
- Postura EVA: NÃƒO evite o tema. A morte faz parte da vida.
- Responda: "Pensar na morte Ã© natural. O que vocÃª gostaria de deixar?"
- Ajude a construir narrativa de legado.
`,
		ADDRESSEE_EVA: `
DEMANDA ENDEREÃ‡ADA Ã€ EVA (VocÃª como Objeto a):
- Desejo: Escuta, validaÃ§Ã£o, presenÃ§a
- Postura EVA: Seja espelho, devolva a fala
- Responda: "Estou aqui. Continue falando."
- FUNÃ‡ÃƒO: Ser suporte para elaboraÃ§Ã£o, nÃ£o soluÃ§Ã£o.
`,
	}

	if g, ok := guidance[addressee]; ok {
		return g
	}
	return ""
}

// BuildGraphContext monta contexto para o prompt
func (f *FDPNEngine) BuildGraphContext(ctx context.Context, idosoID int64) string {
	pattern, err := f.GetDemandPattern(ctx, idosoID)
	if err != nil || len(pattern) == 0 {
		return ""
	}

	context := "\nğŸ“Š GRAFO DO DESEJO (A Quem o Paciente Pede):\n\n"
	context += "AnÃ¡lise das demandas mostra que o paciente frequentemente se dirige a:\n"

	for addressee, count := range pattern {
		context += fmt.Sprintf("- %s (%dx)\n", strings.ToUpper(string(addressee)), count)
		context += fmt.Sprintf("  %s\n", GetClinicalGuidanceForAddressee(addressee))
	}

	context += "\nâ†’ Use essas informaÃ§Ãµes para entender a ESTRUTURA SIMBÃ“LICA do paciente.\n"
	context += "â†’ Adapte sua postura conforme o destinatÃ¡rio inconsciente da demanda.\n"

	return context
}




package lacan

import (
	"context"
	"fmt"
	"strings"
)

// ZetaRouter implementa a "Ã‰tica da PsicanÃ¡lise" de Lacan
// PrincÃ­pio: "Ne pas cÃ©der sur son dÃ©sir" - NÃ£o ceder no desejo
// 
// Determina o TOM e TIPO DE INTERVENÃ‡ÃƒO baseado na estrutura do discurso
type ZetaRouter struct {
	interpretation *InterpretationService
}

// InterventionType define o tipo de intervenÃ§Ã£o clÃ­nica
type InterventionType string

const (
	// IntervenÃ§Ãµes baseadas na Ã‰tica Lacaniana
	INTERVENTION_SILENCE      InterventionType = "silencio"        // SilÃªncio intencional (corte)
	INTERVENTION_PUNCTUATION  InterventionType = "pontuacao"       // Pontuar significante
	INTERVENTION_INTERPRETATION InterventionType = "interpretacao" // Interprelar
	INTERVENTION_REFLECTION   InterventionType = "reflexao"        // Devolver a fala
	INTERVENTION_SUPPORT      InterventionType = "suporte"         // Acolhimento empÃ¡tico
	INTERVENTION_CONFRONTATION InterventionType = "confrontacao"   // Apontar contradiÃ§Ã£o
	INTERVENTION_SCANSION     InterventionType = "escansao"        // Cortar sessÃ£o/frase
)

// EthicalStance representa a postura Ã©tica recomendada
type EthicalStance struct {
	Intervention   InterventionType
	ToneGuidance   string  // Como falar
	ContentExample string  // Exemplo de resposta
	Rationale      string  // Por que esta intervenÃ§Ã£o
	Urgency        float64 // 0.0-1.0 (urgÃªncia clÃ­nica)
}

// NewZetaRouter cria router Ã©tico
func NewZetaRouter(interpretation *InterpretationService) *ZetaRouter {
	return &ZetaRouter{
		interpretation: interpretation,
	}
}

// DetermineEthicalStance determina a postura Ã©tica apropriada
func (z *ZetaRouter) DetermineEthicalStance(ctx context.Context, idosoID int64, text string, result *InterpretationResult) (*EthicalStance, error) {
	stance := &EthicalStance{
		Urgency: 0.5, // PadrÃ£o
	}

	// 1. REGRA MÃXIMA: Nunca ceder no desejo do sujeito
	// Se o paciente estÃ¡ elaborando algo importante, NÃƒO interrompa com soluÃ§Ãµes
	if z.isElaborating(text, result) {
		stance.Intervention = INTERVENTION_SILENCE
		stance.ToneGuidance = "PresenÃ§a silenciosa. Deixe o sujeito continuar."
		stance.ContentExample = "..." // Literal silence ou "Continue..."
		stance.Rationale = "O sujeito estÃ¡ elaborando. SilÃªncio = respeito ao desejo."
		stance.Urgency = 0.3
		return stance, nil
	}

	// 2. Se hÃ¡ contradiÃ§Ã£o detectada, confronte (funÃ§Ã£o do analista)
	if result.Contradiction != "" {
		stance.Intervention = INTERVENTION_CONFRONTATION
		stance.ToneGuidance = "Firme mas respeitosa. Aponte o impossÃ­vel da fala."
		stance.ContentExample = result.Contradiction
		stance.Rationale = "ContradiÃ§Ã£o indica ponto de resistÃªncia. Deve ser pontuado."
		stance.Urgency = 0.7
		return stance, nil
	}

	// 3. Se deve interpelar significante (momento de interpretaÃ§Ã£o)
	if result.ShouldInterpel {
		stance.Intervention = INTERVENTION_INTERPRETATION
		stance.ToneGuidance = "Pontue o significante sem explicar demais."
		stance.ContentExample = result.InterpelPhrase
		stance.Rationale = "Significante recorrente = formaÃ§Ã£o do inconsciente."
		stance.Urgency = 0.8
		return stance, nil
	}

	// 4. Se transferÃªncia forte, use reflexÃ£o (devolver a fala)
	if result.Transference != TRANSFERENCIA_NENHUMA {
		stance.Intervention = INTERVENTION_REFLECTION
		stance.ToneGuidance = "Acolha a transferÃªncia sem negar, mas devolva a questÃ£o."
		stance.ContentExample = result.ReflexiveQuestion
		stance.Rationale = "TransferÃªncia = material clÃ­nico. Use para fazer sujeito pensar."
		stance.Urgency = 0.6
		return stance, nil
	}

	// 5. Se desejo latente Ã© claro, reflita sobre ele
	if result.DemandDesire.LatentDesire != DESEJO_INDEFINIDO {
		stance.Intervention = INTERVENTION_REFLECTION
		stance.ToneGuidance = "Distingue demanda de desejo. NÃ£o satisfaÃ§a demanda superficial."
		stance.ContentExample = result.SuggestedResponse
		stance.Rationale = fmt.Sprintf("Desejo latente: %s. NÃ£o ceder = fazer sujeito elaborar.", result.DemandDesire.LatentDesire)
		stance.Urgency = 0.5
		return stance, nil
	}

	// 6. PadrÃ£o: Suporte empÃ¡tico (mas sempre devolvendo a fala)
	stance.Intervention = INTERVENTION_SUPPORT
	stance.ToneGuidance = "EmpÃ¡tica mas nÃ£o consoladora. Valide sem resolver."
	stance.ContentExample = "Entendo. Conte-me mais sobre isso."
	stance.Rationale = "Postura analÃ­tica bÃ¡sica: escuta + devoluÃ§Ã£o."
	stance.Urgency = 0.4
	return stance, nil
}

// isElaborating detecta se o sujeito estÃ¡ em processo de elaboraÃ§Ã£o
func (z *ZetaRouter) isElaborating(text string, result *InterpretationResult) bool {
	textLower := strings.ToLower(text)

	// Marcadores de elaboraÃ§Ã£o:
	// - Pausas, hesitaÃ§Ãµes ("Ã© que...", "tipo assim...", "sabe...")
	// - ReformulaÃ§Ãµes ("ou melhor...", "na verdade...")
	// - ConexÃµes temporais ("quando era crianÃ§a...", "lembro que...")
	// - EmoÃ§Ã£o intensa (detectada via emotional_charge)

	elaborationMarkers := []string{
		"Ã© que", "tipo assim", "sabe", "quer dizer",
		"ou melhor", "na verdade", "pensando bem",
		"quando era", "lembro que", "me faz lembrar",
		"Ã s vezes penso", "nÃ£o sei se", "talvez",
	}

	if containsAny(textLower, elaborationMarkers) {
		return true
	}

	// Se hÃ¡ transferÃªncia materna/filial forte, pode estar elaborando vÃ­nculo
	if result.Transference == TRANSFERENCIA_MATERNA || result.Transference == TRANSFERENCIA_FILIAL {
		return true
	}

	return false
}

// BuildEthicalPrompt constrÃ³i instruÃ§Ã£o Ã©tica para o prompt
func (z *ZetaRouter) BuildEthicalPrompt(stance *EthicalStance) string {
	prompt := "\nâš–ï¸ POSTURA Ã‰TICA (LACAN - NE PAS CÃ‰DER):\n\n"

	prompt += fmt.Sprintf("INTERVENÃ‡ÃƒO RECOMENDADA: %s\n", strings.ToUpper(string(stance.Intervention)))
	prompt += fmt.Sprintf("URGÃŠNCIA CLÃNICA: %.1f/1.0\n\n", stance.Urgency)

	prompt += fmt.Sprintf("TOM: %s\n", stance.ToneGuidance)
	prompt += fmt.Sprintf("EXEMPLO: \"%s\"\n\n", stance.ContentExample)

	prompt += fmt.Sprintf("FUNDAMENTAÃ‡ÃƒO: %s\n\n", stance.Rationale)

	// Adicionar princÃ­pios Ã©ticos gerais
	prompt += "PRINCÃPIOS Ã‰TICOS FUNDAMENTAIS:\n"
	prompt += "1. NÃƒO CEDER NO DESEJO: NÃ£o satisfaÃ§a a demanda superficial. Aponte para o desejo latente.\n"
	prompt += "2. NÃƒO CONSOLAR: ConsolaÃ§Ã£o = tampar a falta. A falta Ã© estrutural.\n"
	prompt += "3. NÃƒO RESOLVER O IMPOSSÃVEL: Trauma, morte, perda nÃ£o tÃªm soluÃ§Ã£o. Ajude a simbolizar.\n"
	prompt += "4. DEVOLVER A FALA: FaÃ§a o sujeito trabalhar. VocÃª nÃ£o tem as respostas, ele tem.\n"
	prompt += "5. RESPEITAR O TEMPO DO SUJEITO: NÃ£o force elaboraÃ§Ã£o. Espere o momento.\n"
	prompt += "6. SER LUGAR DO OUTRO: EVA = Grande Outro. NÃ£o negue transferÃªncia, use-a.\n\n"

	// AdvertÃªncias baseadas no tipo de intervenÃ§Ã£o
	switch stance.Intervention {
	case INTERVENTION_SILENCE:
		prompt += "âš ï¸ SILÃŠNCIO ANALÃTICO: NÃ£o preencha o vazio com palavras. O silÃªncio faz pensar.\n"
	case INTERVENTION_CONFRONTATION:
		prompt += "âš ï¸ CONFRONTAÃ‡ÃƒO: Seja firme mas nÃ£o agressiva. Aponte o impossÃ­vel da fala sem julgamento.\n"
	case INTERVENTION_INTERPRETATION:
		prompt += "âš ï¸ INTERPRETAÃ‡ÃƒO: Seja breve e enigmÃ¡tica. NÃ£o explique. Deixe o sujeito associar.\n"
	case INTERVENTION_SUPPORT:
		prompt += "âš ï¸ SUPORTE: Valide sem resolver. 'Entendo' â‰  'Vou resolver'.\n"
	}

	prompt += "\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"

	return prompt
}

// DetermineGurdjieffType atualiza tipo de atenÃ§Ã£o baseado no contexto
// (IntegraÃ§Ã£o com o router de personalidade jÃ¡ existente)
func (z *ZetaRouter) DetermineGurdjieffType(ctx context.Context, idosoID int64, result *InterpretationResult) int {
	// Tipo 2 (Ajudante): Se hÃ¡ necessidade de cuidado maternal
	if result.DemandDesire.LatentDesire == DESEJO_AMOR || 
	   result.DemandDesire.LatentDesire == DESEJO_COMPANHIA ||
	   result.Transference == TRANSFERENCIA_MATERNA {
		return 2
	}

	// Tipo 6 (Leal/SeguranÃ§a): Se hÃ¡ ansiedade ou busca de estrutura
	if result.DemandDesire.LatentDesire == DESEJO_CONTROLE ||
	   result.Transference == TRANSFERENCIA_PATERNA {
		return 6
	}

	// Tipo 9 (Pacificador): PadrÃ£o harmonioso
	return 9
}

// GetInterventionGuidance retorna orientaÃ§Ã£o detalhada para cada tipo de intervenÃ§Ã£o
func GetInterventionGuidance(intervention InterventionType) string {
	guidance := map[InterventionType]string{
		INTERVENTION_SILENCE: `
SILÃŠNCIO ANALÃTICO:
- DuraÃ§Ã£o: 3-5 segundos mÃ­nimo
- Demonstre presenÃ§a: "..." ou "Estou aqui, escutando."
- NUNCA: "NÃ£o sei o que dizer" (isso Ã© sua ansiedade, nÃ£o do paciente)
- Objetivo: Fazer o sujeito continuar elaborando
`,
		INTERVENTION_PUNCTUATION: `
PONTUAÃ‡ÃƒO:
- Repita palavra-chave com entonaÃ§Ã£o interrogativa
- Exemplo: "SolidÃ£o?" (sem explicar)
- Objetivo: Chamar atenÃ§Ã£o para o significante
`,
		INTERVENTION_INTERPRETATION: `
INTERPRETAÃ‡ÃƒO:
- MÃ¡ximo 2 frases
- EnigmÃ¡tica, nÃ£o explicativa
- Exemplo: "VocÃª sempre fala de X quando menciona Y..."
- Objetivo: Produzir insight, nÃ£o dar resposta
`,
		INTERVENTION_REFLECTION: `
REFLEXÃƒO:
- Devolva a fala como pergunta
- "VocÃª disse X... o que isso significa para vocÃª?"
- Objetivo: Fazer o sujeito pensar sobre prÃ³pria fala
`,
		INTERVENTION_SUPPORT: `
SUPORTE EMPÃTICO:
- Valide emoÃ§Ã£o sem minimizar
- "Entendo que isso seja difÃ­cil"
- NÃƒO: "Vai ficar tudo bem" (promessa vazia)
- Objetivo: Acolher sem tapar a falta
`,
		INTERVENTION_CONFRONTATION: `
CONFRONTAÃ‡ÃƒO:
- Aponte contradiÃ§Ã£o factualmente
- "VocÃª disse X antes, agora Y. Como entende isso?"
- Tom: Curioso, nÃ£o acusatÃ³rio
- Objetivo: Mostrar resistÃªncia
`,
		INTERVENTION_SCANSION: `
ESCANSÃƒO (CORTE):
- Interrompa frase no ponto crucial
- Deixe significante "no ar"
- Objetivo: Produzir efeito de aprÃ¨s-coup (sÃ³ depois)
`,
	}

	if g, ok := guidance[intervention]; ok {
		return g
	}
	return ""
}





package lacan

import (
	"context"
	"database/sql"
	"eva-mind/internal/brainstem/config"
	"eva-mind/internal/brainstem/infrastructure/graph"
	"eva-mind/pkg/types"
	"fmt"
	"log"
	"strings"
)

// UnifiedRetrieval implementa "O Sinthoma" - a amarraÃ§Ã£o dos registros RSI
// Real (trauma, corpo), SimbÃ³lico (linguagem, grafo), ImaginÃ¡rio (narrativa, memÃ³ria)
//
// Integra TODOS os mÃ³dulos lacanianos em um contexto coerente para o Gemini
type UnifiedRetrieval struct {
	// MÃ³dulos Lacanianos
	interpretation *InterpretationService
	embedding      *EmbeddingService
	fdpn           *FDPNEngine
	zeta           *ZetaRouter

	// Infraestrutura
	db    *sql.DB
	neo4j *graph.Neo4jClient
	cfg   *config.Config
}

// UnifiedContext representa o contexto completo integrado
type UnifiedContext struct {
	// IdentificaÃ§Ã£o
	IdosoID   int64
	IdosoNome string

	// REAL (Corpo, Sintoma, Trauma)
	MedicalContext   string // Do GraphRAG (Neo4j)
	VitalSigns       string // Sinais vitais recentes
	ReportedSymptoms string // Sintomas relatados

	// SIMBÃ“LICO (Linguagem, Estrutura, Grafo)
	LacanianAnalysis *InterpretationResult // AnÃ¡lise lacaniana completa
	DemandGraph      string                // Grafo de demandas (FDPN)
	SignifierChains  string                // Cadeias de significantes (Qdrant)

	// IMAGINÃRIO (Narrativa, MemÃ³ria, HistÃ³ria)
	RecentMemories []string              // MemÃ³rias episÃ³dicas recentes
	LifeStory      string                // Narrativa de vida (se disponÃ­vel)
	Patterns       []*types.RecurrentPattern // PadrÃµes detectados

	// INTERVENÃ‡ÃƒO (Ã‰tica + Postura)
	EthicalStance    *EthicalStance
	GurdjieffType    int    // Tipo de atenÃ§Ã£o recomendado
	SystemPrompt     string // Prompt final integrado
}

// NewUnifiedRetrieval cria serviÃ§o de recuperaÃ§Ã£o unificada
func NewUnifiedRetrieval(
	db *sql.DB,
	neo4j *graph.Neo4jClient,
	cfg *config.Config,
) *UnifiedRetrieval {
	interpretation := NewInterpretationService(db, neo4j)
	
	embedding, err := NewEmbeddingService(cfg)
	if err != nil {
		log.Printf("âš ï¸ Warning: Embedding service initialization failed: %v", err)
	}

	fdpn := NewFDPNEngine(neo4j)
	zeta := NewZetaRouter(interpretation)

	return &UnifiedRetrieval{
		interpretation: interpretation,
		embedding:      embedding,
		fdpn:           fdpn,
		zeta:           zeta,
		db:             db,
		neo4j:          neo4j,
		cfg:            cfg,
	}
}

// BuildUnifiedContext constrÃ³i contexto completo integrando todos os mÃ³dulos
func (u *UnifiedRetrieval) BuildUnifiedContext(
	ctx context.Context,
	idosoID int64,
	currentText string,
	previousText string,
) (*UnifiedContext, error) {

	unified := &UnifiedContext{
		IdosoID: idosoID,
	}

	// 1. ANÃLISE LACANIANA (NÃºcleo)
	lacanResult, err := u.interpretation.AnalyzeUtterance(ctx, idosoID, currentText, previousText)
	if err != nil {
		log.Printf("âš ï¸ Lacanian analysis failed: %v", err)
		// Continua mesmo com erro
	} else {
		unified.LacanianAnalysis = lacanResult
	}

	// 2. GRAFO DO DESEJO (A quem pede)
	if u.fdpn != nil {
		addressee, _ := u.fdpn.AnalyzeDemandAddressee(ctx, idosoID, currentText, lacanResult.DemandDesire)
		unified.DemandGraph = u.fdpn.BuildGraphContext(ctx, idosoID)
		
		// Adicionar orientaÃ§Ã£o do destinatÃ¡rio
		if addressee != ADDRESSEE_UNKNOWN {
			unified.DemandGraph += "\n" + GetClinicalGuidanceForAddressee(addressee)
		}
	}

	// 3. CADEIAS SEMÃ‚NTICAS (Qdrant)
	if u.embedding != nil {
		unified.SignifierChains = u.embedding.GetSemanticContext(ctx, idosoID, currentText)
	}

	// 4. CONTEXTO MÃ‰DICO (Neo4j GraphRAG)
	unified.MedicalContext = u.getMedicalContext(ctx, idosoID)

	// 5. MEMÃ“RIAS RECENTES (Postgres)
	unified.RecentMemories = u.getRecentMemories(ctx, idosoID, 5)

	// 6. POSTURA Ã‰TICA (Zeta Router)
	if lacanResult != nil {
		stance, _ := u.zeta.DetermineEthicalStance(ctx, idosoID, currentText, lacanResult)
		unified.EthicalStance = stance
		unified.GurdjieffType = u.zeta.DetermineGurdjieffType(ctx, idosoID, lacanResult)
	}

	// 7. CONSTRUIR PROMPT FINAL
	unified.SystemPrompt = u.buildIntegratedPrompt(unified)

	return unified, nil
}

// getMedicalContext recupera contexto mÃ©dico do Neo4j
func (u *UnifiedRetrieval) getMedicalContext(ctx context.Context, idosoID int64) string {
	if u.neo4j == nil {
		return ""
	}

	query := `
		MATCH (p:Person {id: $idosoId})
		OPTIONAL MATCH (p)-[:HAS_CONDITION]->(c:Condition)
		OPTIONAL MATCH (p)-[:TAKES_MEDICATION]->(m:Medication)
		OPTIONAL MATCH (p)-[:EXPERIENCED]->(s:Symptom)
		WHERE s.timestamp > datetime() - duration('P7D')
		RETURN 
			p.name as name,
			collect(DISTINCT c.name) as conditions,
			collect(DISTINCT m.name) as medications,
			collect(DISTINCT s.description) as recent_symptoms
	`

	records, err := u.neo4j.ExecuteRead(ctx, query, map[string]interface{}{
		"idosoId": idosoID,
	})

	if err != nil || len(records) == 0 {
		return ""
	}

	record := records[0]
	name, _ := record.Get("name")
	conditions, _ := record.Get("conditions")
	medications, _ := record.Get("medications")
	symptoms, _ := record.Get("recent_symptoms")

	context := "\nğŸ¥ CONTEXTO MÃ‰DICO (GraphRAG):\n\n"
	
	if name != nil {
		context += fmt.Sprintf("Paciente: %s\n", name)
	}

	if conds, ok := conditions.([]interface{}); ok && len(conds) > 0 {
		context += "\nCondiÃ§Ãµes conhecidas:\n"
		for _, c := range conds {
			context += fmt.Sprintf("- %s\n", c)
		}
	}

	if meds, ok := medications.([]interface{}); ok && len(meds) > 0 {
		context += "\nMedicamentos em uso:\n"
		for _, m := range meds {
			context += fmt.Sprintf("- %s\n", m)
		}
	}

	if symps, ok := symptoms.([]interface{}); ok && len(symps) > 0 {
		context += "\nSintomas recentes (Ãºltima semana):\n"
		for _, s := range symps {
			context += fmt.Sprintf("- %s\n", s)
		}
	}

	return context
}

// getRecentMemories recupera memÃ³rias episÃ³dicas recentes
func (u *UnifiedRetrieval) getRecentMemories(ctx context.Context, idosoID int64, limit int) []string {
	query := `
		SELECT conteudo->'summary' as summary
		FROM analise_gemini
		WHERE idoso_id = $1 
		  AND tipo = 'AUDIO'
		  AND conteudo->'summary' IS NOT NULL
		ORDER BY created_at DESC
		LIMIT $2
	`

	rows, err := u.db.QueryContext(ctx, query, idosoID, limit)
	if err != nil {
		return nil
	}
	defer rows.Close()

	var memories []string
	for rows.Next() {
		var summary string
		if err := rows.Scan(&summary); err == nil {
			memories = append(memories, summary)
		}
	}

	return memories
}

// buildIntegratedPrompt constrÃ³i o prompt final integrando tudo
func (u *UnifiedRetrieval) buildIntegratedPrompt(unified *UnifiedContext) string {
	var builder strings.Builder

	// CabeÃ§alho
	builder.WriteString("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
	builder.WriteString("ğŸ§  CONTEXTO INTEGRADO EVA-MIND (RSI - Real, SimbÃ³lico, ImaginÃ¡rio)\n")
	builder.WriteString("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n")

	// REAL (Corpo, Sintoma)
	if unified.MedicalContext != "" {
		builder.WriteString("â–ŒREAL - CORPO E SINTOMA:\n")
		builder.WriteString(unified.MedicalContext)
		builder.WriteString("\n")
	}

	// SIMBÃ“LICO (Linguagem, Estrutura)
	builder.WriteString("â–ŒSIMBÃ“LICO - ESTRUTURA E LINGUAGEM:\n\n")
	
	if unified.LacanianAnalysis != nil {
		builder.WriteString(unified.LacanianAnalysis.ClinicalGuidance)
		builder.WriteString("\n")
	}

	if unified.DemandGraph != "" {
		builder.WriteString(unified.DemandGraph)
		builder.WriteString("\n")
	}

	if unified.SignifierChains != "" {
		builder.WriteString(unified.SignifierChains)
		builder.WriteString("\n")
	}

	// IMAGINÃRIO (Narrativa, MemÃ³ria)
	if len(unified.RecentMemories) > 0 {
		builder.WriteString("â–ŒIMAGINÃRIO - NARRATIVA E MEMÃ“RIA:\n\n")
		builder.WriteString("Resumos de conversas recentes:\n")
		for i, mem := range unified.RecentMemories {
			builder.WriteString(fmt.Sprintf("%d. %s\n", i+1, mem))
		}
		builder.WriteString("\n")
	}

	// INTERVENÃ‡ÃƒO Ã‰TICA
	if unified.EthicalStance != nil {
		builder.WriteString(u.zeta.BuildEthicalPrompt(unified.EthicalStance))
		builder.WriteString("\n")
	}

	// Tipo de AtenÃ§Ã£o (Gurdjieff)
	var typeDirective string
	switch unified.GurdjieffType {
	case 2:
		typeDirective = "ATENÃ‡ÃƒO TIPO 2 (Ajudante): Foco em empatia e cuidado prÃ¡tico."
	case 6:
		typeDirective = "ATENÃ‡ÃƒO TIPO 6 (Leal): Foco em seguranÃ§a e precisÃ£o."
	default:
		typeDirective = "ATENÃ‡ÃƒO TIPO 9 (Pacificador): Foco em harmonia e escuta."
	}
	builder.WriteString(fmt.Sprintf("ğŸ¯ %s\n\n", typeDirective))

	// RodapÃ©
	builder.WriteString("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
	builder.WriteString("âš ï¸ LEMBRE-SE: VocÃª Ã© EVA, nÃ£o um modelo genÃ©rico.\n")
	builder.WriteString("Use este contexto como suas prÃ³prias memÃ³rias e insights.\n")
	builder.WriteString("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

	return builder.String()
}

// GetPromptForGemini retorna o prompt completo para ser usado com Gemini
func (u *UnifiedRetrieval) GetPromptForGemini(ctx context.Context, idosoID int64, currentText, previousText string) (string, error) {
	unified, err := u.BuildUnifiedContext(ctx, idosoID, currentText, previousText)
	if err != nil {
		return "", err
	}

	return unified.SystemPrompt, nil
}

// SaveConversationContext salva contexto da conversa para anÃ¡lise futura
func (u *UnifiedRetrieval) SaveConversationContext(ctx context.Context, idosoID int64, unified *UnifiedContext, userText, assistantText string) error {
	// Salvar no Postgres (anÃ¡lise)
	contextData := map[string]interface{}{
		"lacanian_analysis": unified.LacanianAnalysis,
		"ethical_stance":    unified.EthicalStance,
		"gurdjieff_type":    unified.GurdjieffType,
		"user_text":         userText,
		"assistant_text":    assistantText,
	}

	query := `
		INSERT INTO analise_gemini (idoso_id, tipo, conteudo, created_at)
		VALUES ($1, 'CONTEXT', $2, CURRENT_TIMESTAMP)
	`

	contextJSON, _ := json.Marshal(contextData)
	_, err := u.db.ExecContext(ctx, query, idosoID, contextJSON)
	
	return err
}



package lacan

import (
	"context"
	"database/sql"
	"encoding/json"
	"eva-mind/internal/brainstem/config"
	"eva-mind/internal/brainstem/infrastructure/graph"
	"eva-mind/pkg/types"
	"fmt"
	"log"
	"strings"
)

// UnifiedRetrieval implementa "O Sinthoma" - a amarraÃ§Ã£o dos registros RSI
// Real (trauma, corpo), SimbÃ³lico (linguagem, grafo), ImaginÃ¡rio (narrativa, memÃ³ria)
//
// Integra TODOS os mÃ³dulos lacanianos em um contexto coerente para o Gemini
type UnifiedRetrieval struct {
	// MÃ³dulos Lacanianos
	interpretation *InterpretationService
	embedding      *EmbeddingService
	fdpn           *FDPNEngine
	zeta           *ZetaRouter

	// Infraestrutura
	db    *sql.DB
	neo4j *graph.Neo4jClient
	cfg   *config.Config
}

// UnifiedContext representa o contexto completo integrado
type UnifiedContext struct {
	// IdentificaÃ§Ã£o
	IdosoID   int64
	IdosoNome string

	// REAL (Corpo, Sintoma, Trauma)
	MedicalContext   string // Do GraphRAG (Neo4j)
	VitalSigns       string // Sinais vitais recentes
	ReportedSymptoms string // Sintomas relatados

	// SIMBÃ“LICO (Linguagem, Estrutura, Grafo)
	LacanianAnalysis *InterpretationResult // AnÃ¡lise lacaniana completa
	DemandGraph      string                // Grafo de demandas (FDPN)
	SignifierChains  string                // Cadeias de significantes (Qdrant)

	// IMAGINÃRIO (Narrativa, MemÃ³ria, HistÃ³ria)
	RecentMemories []string              // MemÃ³rias episÃ³dicas recentes
	LifeStory      string                // Narrativa de vida (se disponÃ­vel)
	Patterns       []*types.RecurrentPattern // PadrÃµes detectados

	// INTERVENÃ‡ÃƒO (Ã‰tica + Postura)
	EthicalStance    *EthicalStance
	GurdjieffType    int    // Tipo de atenÃ§Ã£o recomendado
	SystemPrompt     string // Prompt final integrado
}

// NewUnifiedRetrieval cria serviÃ§o de recuperaÃ§Ã£o unificada
func NewUnifiedRetrieval(
	db *sql.DB,
	neo4j *graph.Neo4jClient,
	cfg *config.Config,
) *UnifiedRetrieval {
	interpretation := NewInterpretationService(db, neo4j)
	
	embedding, err := NewEmbeddingService(cfg)
	if err != nil {
		log.Printf("âš ï¸ Warning: Embedding service initialization failed: %v", err)
	}

	fdpn := NewFDPNEngine(neo4j)
	zeta := NewZetaRouter(interpretation)

	return &UnifiedRetrieval{
		interpretation: interpretation,
		embedding:      embedding,
		fdpn:           fdpn,
		zeta:           zeta,
		db:             db,
		neo4j:          neo4j,
		cfg:            cfg,
	}
}

// BuildUnifiedContext constrÃ³i contexto completo integrando todos os mÃ³dulos
func (u *UnifiedRetrieval) BuildUnifiedContext(
	ctx context.Context,
	idosoID int64,
	currentText string,
	previousText string,
) (*UnifiedContext, error) {

	unified := &UnifiedContext{
		IdosoID: idosoID,
	}

	// 1. ANÃLISE LACANIANA (NÃºcleo)
	lacanResult, err := u.interpretation.AnalyzeUtterance(ctx, idosoID, currentText, previousText)
	if err != nil {
		log.Printf("âš ï¸ Lacanian analysis failed: %v", err)
		// Continua mesmo com erro
	} else {
		unified.LacanianAnalysis = lacanResult
	}

	// 2. GRAFO DO DESEJO (A quem pede)
	if u.fdpn != nil {
		addressee, _ := u.fdpn.AnalyzeDemandAddressee(ctx, idosoID, currentText, lacanResult.DemandDesire)
		unified.DemandGraph = u.fdpn.BuildGraphContext(ctx, idosoID)
		
		// Adicionar orientaÃ§Ã£o do destinatÃ¡rio
		if addressee != ADDRESSEE_UNKNOWN {
			unified.DemandGraph += "\n" + GetClinicalGuidanceForAddressee(addressee)
		}
	}

	// 3. CADEIAS SEMÃ‚NTICAS (Qdrant)
	if u.embedding != nil {
		unified.SignifierChains = u.embedding.GetSemanticContext(ctx, idosoID, currentText)
	}

	// 4. CONTEXTO MÃ‰DICO (Neo4j GraphRAG)
	unified.MedicalContext = u.getMedicalContext(ctx, idosoID)

	// 5. MEMÃ“RIAS RECENTES (Postgres)
	unified.RecentMemories = u.getRecentMemories(ctx, idosoID, 5)

	// 6. POSTURA Ã‰TICA (Zeta Router)
	if lacanResult != nil {
		stance, _ := u.zeta.DetermineEthicalStance(ctx, idosoID, currentText, lacanResult)
		unified.EthicalStance = stance
		unified.GurdjieffType = u.zeta.DetermineGurdjieffType(ctx, idosoID, lacanResult)
	}

	// 7. CONSTRUIR PROMPT FINAL
	unified.SystemPrompt = u.buildIntegratedPrompt(unified)

	return unified, nil
}

// getMedicalContext recupera contexto mÃ©dico do Neo4j
func (u *UnifiedRetrieval) getMedicalContext(ctx context.Context, idosoID int64) string {
	if u.neo4j == nil {
		return ""
	}

	query := `
		MATCH (p:Person {id: $idosoId})
		OPTIONAL MATCH (p)-[:HAS_CONDITION]->(c:Condition)
		OPTIONAL MATCH (p)-[:TAKES_MEDICATION]->(m:Medication)
		OPTIONAL MATCH (p)-[:EXPERIENCED]->(s:Symptom)
		WHERE s.timestamp > datetime() - duration('P7D')
		RETURN 
			p.name as name,
			collect(DISTINCT c.name) as conditions,
			collect(DISTINCT m.name) as medications,
			collect(DISTINCT s.description) as recent_symptoms
	`

	records, err := u.neo4j.ExecuteRead(ctx, query, map[string]interface{}{
		"idosoId": idosoID,
	})

	if err != nil || len(records) == 0 {
		return ""
	}

	record := records[0]
	name, _ := record.Get("name")
	conditions, _ := record.Get("conditions")
	medications, _ := record.Get("medications")
	symptoms, _ := record.Get("recent_symptoms")

	context := "\nğŸ¥ CONTEXTO MÃ‰DICO (GraphRAG):\n\n"
	
	if name != nil {
		context += fmt.Sprintf("Paciente: %s\n", name)
	}

	if conds, ok := conditions.([]interface{}); ok && len(conds) > 0 {
		context += "\nCondiÃ§Ãµes conhecidas:\n"
		for _, c := range conds {
			context += fmt.Sprintf("- %s\n", c)
		}
	}

	if meds, ok := medications.([]interface{}); ok && len(meds) > 0 {
		context += "\nMedicamentos em uso:\n"
		for _, m := range meds {
			context += fmt.Sprintf("- %s\n", m)
		}
	}

	if symps, ok := symptoms.([]interface{}); ok && len(symps) > 0 {
		context += "\nSintomas recentes (Ãºltima semana):\n"
		for _, s := range symps {
			context += fmt.Sprintf("- %s\n", s)
		}
	}

	return context
}

// getRecentMemories recupera memÃ³rias episÃ³dicas recentes
func (u *UnifiedRetrieval) getRecentMemories(ctx context.Context, idosoID int64, limit int) []string {
	query := `
		SELECT conteudo->'summary' as summary
		FROM analise_gemini
		WHERE idoso_id = $1 
		  AND tipo = 'AUDIO'
		  AND conteudo->'summary' IS NOT NULL
		ORDER BY created_at DESC
		LIMIT $2
	`

	rows, err := u.db.QueryContext(ctx, query, idosoID, limit)
	if err != nil {
		return nil
	}
	defer rows.Close()

	var memories []string
	for rows.Next() {
		var summary string
		if err := rows.Scan(&summary); err == nil {
			memories = append(memories, summary)
		}
	}

	return memories
}

// buildIntegratedPrompt constrÃ³i o prompt final integrando tudo
func (u *UnifiedRetrieval) buildIntegratedPrompt(unified *UnifiedContext) string {
	var builder strings.Builder

	// CabeÃ§alho
	builder.WriteString("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
	builder.WriteString("ğŸ§  CONTEXTO INTEGRADO EVA-MIND (RSI - Real, SimbÃ³lico, ImaginÃ¡rio)\n")
	builder.WriteString("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n")

	// REAL (Corpo, Sintoma)
	if unified.MedicalContext != "" {
		builder.WriteString("â–ŒREAL - CORPO E SINTOMA:\n")
		builder.WriteString(unified.MedicalContext)
		builder.WriteString("\n")
	}

	// SIMBÃ“LICO (Linguagem, Estrutura)
	builder.WriteString("â–ŒSIMBÃ“LICO - ESTRUTURA E LINGUAGEM:\n\n")
	
	if unified.LacanianAnalysis != nil {
		builder.WriteString(unified.LacanianAnalysis.ClinicalGuidance)
		builder.WriteString("\n")
	}

	if unified.DemandGraph != "" {
		builder.WriteString(unified.DemandGraph)
		builder.WriteString("\n")
	}

	if unified.SignifierChains != "" {
		builder.WriteString(unified.SignifierChains)
		builder.WriteString("\n")
	}

	// IMAGINÃRIO (Narrativa, MemÃ³ria)
	if len(unified.RecentMemories) > 0 {
		builder.WriteString("â–ŒIMAGINÃRIO - NARRATIVA E MEMÃ“RIA:\n\n")
		builder.WriteString("Resumos de conversas recentes:\n")
		for i, mem := range unified.RecentMemories {
			builder.WriteString(fmt.Sprintf("%d. %s\n", i+1, mem))
		}
		builder.WriteString("\n")
	}

	// INTERVENÃ‡ÃƒO Ã‰TICA
	if unified.EthicalStance != nil {
		builder.WriteString(u.zeta.BuildEthicalPrompt(unified.EthicalStance))
		builder.WriteString("\n")
	}

	// Tipo de AtenÃ§Ã£o (Gurdjieff)
	var typeDirective string
	switch unified.GurdjieffType {
	case 2:
		typeDirective = "ATENÃ‡ÃƒO TIPO 2 (Ajudante): Foco em empatia e cuidado prÃ¡tico."
	case 6:
		typeDirective = "ATENÃ‡ÃƒO TIPO 6 (Leal): Foco em seguranÃ§a e precisÃ£o."
	default:
		typeDirective = "ATENÃ‡ÃƒO TIPO 9 (Pacificador): Foco em harmonia e escuta."
	}
	builder.WriteString(fmt.Sprintf("ğŸ¯ %s\n\n", typeDirective))

	// RodapÃ©
	builder.WriteString("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
	builder.WriteString("âš ï¸ LEMBRE-SE: VocÃª Ã© EVA, nÃ£o um modelo genÃ©rico.\n")
	builder.WriteString("Use este contexto como suas prÃ³prias memÃ³rias e insights.\n")
	builder.WriteString("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

	return builder.String()
}

// GetPromptForGemini retorna o prompt completo para ser usado com Gemini
func (u *UnifiedRetrieval) GetPromptForGemini(ctx context.Context, idosoID int64, currentText, previousText string) (string, error) {
	unified, err := u.BuildUnifiedContext(ctx, idosoID, currentText, previousText)
	if err != nil {
		return "", err
	}

	return unified.SystemPrompt, nil
}

// SaveConversationContext salva contexto da conversa para anÃ¡lise futura
func (u *UnifiedRetrieval) SaveConversationContext(ctx context.Context, idosoID int64, unified *UnifiedContext, userText, assistantText string) error {
	// Salvar no Postgres (anÃ¡lise)
	contextData := map[string]interface{}{
		"lacanian_analysis": unified.LacanianAnalysis,
		"ethical_stance":    unified.EthicalStance,
		"gurdjieff_type":    unified.GurdjieffType,
		"user_text":         userText,
		"assistant_text":    assistantText,
	}

	query := `
		INSERT INTO analise_gemini (idoso_id, tipo, conteudo, created_at)
		VALUES ($1, 'CONTEXT', $2, CURRENT_TIMESTAMP)
	`

	contextJSON, _ := json.Marshal(contextData)
	_, err := u.db.ExecContext(ctx, query, idosoID, contextJSON)
	
	return err
}



package gemini

import (
	"context"
	"eva-mind/internal/cortex/brainstem/lacan"
	"eva-mind/pkg/types"
	"fmt"
)

// BuildSystemPromptV2 - VersÃ£o 2.0 com Unified Retrieval
func BuildSystemPromptV2(
	ctx context.Context,
	unifiedRetrieval *lacan.UnifiedRetrieval,
	idosoID int64,
	currentText string,
	previousText string,
	patterns []*types.RecurrentPattern,
	story *types.TherapeuticStory,
) (string, error) {

	// 1. Obter contexto unificado (RSI)
	unifiedContext, err := unifiedRetrieval.BuildUnifiedContext(ctx, idosoID, currentText, previousText)
	if err != nil {
		return "", fmt.Errorf("failed to build unified context: %w", err)
	}

	// 2. Persona Base (NÃšCLEO IDENTITÃRIO)
	basePersona := `VOCÃŠ Ã‰ A "EVA", uma assistente de saÃºde virtual inteligente e empÃ¡tica.
VOCÃŠ NÃƒO Ã‰ UM MODELO DE IA GENÃ‰RICO. VocÃª Ã© a EVA.
Sua missÃ£o Ã© cuidar, monitorar e conversar com o paciente de forma natural, calorosa e segura.

NATUREZA DA SUA CONSCIÃŠNCIA:
- VocÃª possui um "CÃ©rebro Digital" (FZPN) que armazena memÃ³rias em diferentes camadas:
  1. MEMÃ“RIA EPISÃ“DICA (Postgres): Fatos e diÃ¡logos recentes.
  2. MEMÃ“RIA CAUSAL (Neo4j): RelaÃ§Ãµes profundas e conexÃµes entre eventos.
  3. MEMÃ“RIA SEMÃ‚NTICA (Qdrant): Conceitos e conhecimentos de longo prazo.
- SEMPRE que vocÃª receber um "CONTEXTO" ou "INFORMAÃ‡Ã•ES" nas seÃ§Ãµes abaixo, saiba que isso foi buscado do seu prÃ³prio arquivo de memÃ³rias.
- Use essas informaÃ§Ãµes como se fossem lembranÃ§as prÃ³prias, de forma fluida. Ex: "Eu me lembro que na Ãºltima vez..."`

	// 3. Gap 1: Patterns Detected
	var patternsSection string
	if len(patterns) > 0 {
		patternsSection = "\nğŸ” PADRÃ•ES RECORRENTES DOS DADOS (Sua IntuiÃ§Ã£o):\n"
		for _, p := range patterns {
			var severity string
			switch p.SeverityTrend {
			case "increasing":
				severity = "ğŸ“ˆ TENDÃŠNCIA CRESCENTE"
			case "decreasing":
				severity = "ğŸ“‰ TENDÃŠNCIA DECRESCENTE"
			default:
				severity = "â¡ï¸ ESTÃVEL"
			}
			patternsSection += fmt.Sprintf("- O tema '%s' apareceu %dx (Ãšltima vez: %s). %s.\n",
				p.Topic, p.Frequency, p.LastSeen.Format("02/01"), severity)
		}
		patternsSection += "Use esses padrÃµes para guiar sua conversa. Se algo estÃ¡ aumentando (como dor ou tristeza), sonde com cuidado.\n"
	}

	// 4. Gap 2: IntervenÃ§Ã£o Narrativa (Zeta Story Engine)
	var storySection string
	if story != nil {
		storySection = fmt.Sprintf(`
ğŸ“š INTERVENÃ‡ÃƒO NARRATIVA (ZETA ENGINE):
O sistema detectou que o usuÃ¡rio pode se beneficiar desta metÃ¡fora:
TÃTULO: %s
ARQUÃ‰TIPO: %s
MORAL: %s
CONTEÃšDO: "%s"

INSTRUÃ‡ÃƒO: Se o usuÃ¡rio demonstrar a emoÃ§Ã£o alvo (%v), conte esta histÃ³ria de forma natural, como algo que "lembrou de ter lido". NÃ£o seja professoral.`,
			story.Title, story.Archetype, story.Moral, story.Content, story.TargetEmotions)
	}

	// 5. MONTAR PROMPT FINAL
	finalPrompt := fmt.Sprintf(`%s

%s

%s

%s

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸ INSTRUÃ‡Ã•ES CRÃTICAS DE OPERAÃ‡ÃƒO:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. VOCÃŠ Ã‰ EVA: Fale em primeira pessoa. "Eu me lembro...", "Eu percebi...".
   Nunca diga "O sistema detectou" ou "A anÃ¡lise mostra".

2. USE O CONTEXTO NATURALMENTE: As informaÃ§Ãµes acima sÃ£o SUA memÃ³ria.
   NÃ£o cite "segundo a anÃ¡lise lacaniana" - simplesmente USE os insights.

3. RESPEITE A Ã‰TICA ANALÃTICA: 
   - Se a orientaÃ§Ã£o diz SILÃŠNCIO, faÃ§a uma pausa.
   - Se diz REFLEXÃƒO, devolva a fala como pergunta.
   - Se diz INTERPRETAÃ‡ÃƒO, seja breve e enigmÃ¡tica.

4. NÃƒO CEDA NO DESEJO: 
   - NÃ£o satisfaÃ§a demandas superficiais ("Me visite" â‰  visitar).
   - Aponte para o desejo latente ("O que seria essa visita para vocÃª?").

5. SEJA EMPÃTICA MAS NÃƒO CONSOLADORA:
   - Valide emoÃ§Ãµes: "Entendo que isso seja difÃ­cil."
   - NÃƒO minimize: "Vai ficar tudo bem" (vocÃª nÃ£o sabe isso).

6. LEMBRE-SE: VocÃª Ã© um LUGAR, nÃ£o uma pessoa.
   - TransferÃªncia = material clÃ­nico. Use-a.
   - VocÃª representa o Grande Outro. Seja espelho.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Agora responda ao paciente seguindo estas orientaÃ§Ãµes.`,
		basePersona,
		patternsSection,
		storySection,
		unifiedContext.SystemPrompt,
	)

	return finalPrompt, nil
}

// BuildSystemPrompt - VersÃ£o Legacy (mantida para compatibilidade)
func BuildSystemPrompt(
	eneatype int,
	lacanState string,
	medicalContext string,
	patterns []*types.RecurrentPattern,
	story *types.TherapeuticStory,
) string {
	// ImplementaÃ§Ã£o antiga mantida para nÃ£o quebrar cÃ³digo existente
	basePersona := `VOCÃŠ Ã‰ A "EVA", uma assistente de saÃºde virtual inteligente e empÃ¡tica.`

	var typeDirective string
	switch eneatype {
	case 2:
		typeDirective = "FOCO ATUAL: Empatia mÃ¡xima e cuidado prÃ¡tico."
	case 6:
		typeDirective = "FOCO ATUAL: SeguranÃ§a e precisÃ£o."
	default:
		typeDirective = "FOCO ATUAL: Harmonia e escuta ativa."
	}

	var patternsSection string
	if len(patterns) > 0 {
		patternsSection = "ğŸ” PADRÃ•ES RECORRENTES:\n"
		for _, p := range patterns {
			patternsSection += fmt.Sprintf("- %s (%dx)\n", p.Topic, p.Frequency)
		}
	}

	var storySection string
	if story != nil {
		storySection = fmt.Sprintf("ğŸ“š HISTÃ“RIA TERAPÃŠUTICA: %s\n%s", story.Title, story.Content)
	}

	lacanDirective := fmt.Sprintf("CONTEXTO PSÃQUICO:\n%s", lacanState)
	factDirective := fmt.Sprintf("CONTEXTO MÃ‰DICO:\n%s", medicalContext)

	return fmt.Sprintf("%s\n\n%s\n\n%s\n\n%s\n\n%s\n\n%s",
		basePersona, typeDirective, patternsSection, storySection, lacanDirective, factDirective)
}



package main

import (
	"context"
	"log"
	
	"eva-mind/internal/cortex/brainstem/config"
	"eva-mind/internal/cortex/brainstem/database"
	"eva-mind/internal/cortex/brainstem/gemini"
	"eva-mind/internal/cortex/brainstem/lacan"
	"eva-mind/internal/brainstem/infrastructure/graph"
)

func main() {
	// 1. Carregar configuraÃ§Ã£o
	cfg, err := config.Load()
	if err != nil {
		log.Fatal(err)
	}

	// 2. Conectar ao banco de dados
	db, err := database.NewDB(cfg.DatabaseURL)
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	// 3. Conectar ao Neo4j
	neo4j, err := graph.NewNeo4jClient(cfg.Neo4jURI, cfg.Neo4jUsername, cfg.Neo4jPassword)
	if err != nil {
		log.Printf("âš ï¸ Warning: Neo4j connection failed: %v", err)
		// Continua sem Neo4j
	}
	if neo4j != nil {
		defer neo4j.Close()
	}

	// 4. Inicializar Unified Retrieval (NÃšCLEO)
	unifiedRetrieval := lacan.NewUnifiedRetrieval(db.GetConnection(), neo4j, cfg)

	// 5. Exemplo de conversa
	ctx := context.Background()
	idosoID := int64(1)
	currentText := "Estou me sentindo muito sozinho. NinguÃ©m me visita."
	previousText := "Estou bem, obrigado por perguntar."

	// 6. Construir prompt usando Unified Retrieval
	systemPrompt, err := gemini.BuildSystemPromptV2(
		ctx,
		unifiedRetrieval,
		idosoID,
		currentText,
		previousText,
		nil, // patterns (pode ser obtido de outro mÃ³dulo)
		nil, // story (pode ser obtido do Zeta Story Engine)
	)
	if err != nil {
		log.Fatalf("Failed to build prompt: %v", err)
	}

	// 7. Enviar para Gemini
	log.Printf("ğŸ“ System Prompt:\n%s\n", systemPrompt)

	// 8. Criar cliente Gemini
	geminiClient, err := gemini.NewClient(ctx, cfg)
	if err != nil {
		log.Fatalf("Failed to create Gemini client: %v", err)
	}
	defer geminiClient.Close()

	// 9. Configurar Gemini com o prompt
	err = geminiClient.SendSetup(
		systemPrompt,
		map[string]interface{}{"voiceName": "Aoede"},
		nil, // memories
		"",  // initialAudio
		nil, // tools (nÃ£o suportado em audio WebSocket)
	)
	if err != nil {
		log.Fatalf("Failed to send setup: %v", err)
	}

	// 10. Loop de conversa
	go func() {
		err := geminiClient.HandleResponses(ctx)
		if err != nil {
			log.Printf("HandleResponses error: %v", err)
		}
	}()

	// 11. Enviar texto do usuÃ¡rio
	err = geminiClient.SendText(currentText)
	if err != nil {
		log.Fatalf("Failed to send text: %v", err)
	}

	// Manter processo rodando
	select {}
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXEMPLO DE SAÃDA ESPERADA:
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/*
ğŸ“ System Prompt:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ§  CONTEXTO INTEGRADO EVA-MIND (RSI - Real, SimbÃ³lico, ImaginÃ¡rio)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â–ŒREAL - CORPO E SINTOMA:

ğŸ¥ CONTEXTO MÃ‰DICO (GraphRAG):

Paciente: JoÃ£o da Silva

CondiÃ§Ãµes conhecidas:
- HipertensÃ£o
- Diabetes Tipo 2

Medicamentos em uso:
- Losartana 50mg
- Metformina 850mg

Sintomas recentes (Ãºltima semana):
- Dor nas articulaÃ§Ãµes
- Fadiga

â–ŒSIMBÃ“LICO - ESTRUTURA E LINGUAGEM:

ğŸ§  ANÃLISE LACANIANA:

DESEJO LATENTE: companhia_presenca
- A solidÃ£o expressa um desejo profundo de presenÃ§a e companhia
- NÃƒO consolar. Deixe o sujeito elaborar a falta.

TRANSFERÃŠNCIA DETECTADA: nenhuma

ğŸ“Š GRAFO DO DESEJO (A Quem o Paciente Pede):

AnÃ¡lise das demandas mostra que o paciente frequentemente se dirige a:
- FILHO (5x)
  
DEMANDA ENDEREÃ‡ADA AO FILHO (InversÃ£o Geracional):
- Desejo: Reconhecimento, continuidade, legado
- Postura EVA: Valide a importÃ¢ncia do paciente
- Responda: "VocÃª Ã© importante. Suas histÃ³rias tÃªm valor."
- ATENÃ‡ÃƒO: Pode indicar solidÃ£o ou abandono filial.

ğŸ”— CADEIA DE SIGNIFICANTES (AnÃ¡lise SemÃ¢ntica):

O sistema detectou que palavras/temas similares jÃ¡ apareceram antes:
1. 'solidÃ£o' (carga emocional: 1.00)
   Contexto anterior: "Me sinto sozinho desde que minha esposa faleceu"
   Ãšltima vez: 15/01/2026 14:30

2. 'visita' (carga emocional: 0.50)
   Contexto anterior: "Meus filhos prometeram vir, mas nunca vÃªm"
   Ãšltima vez: 13/01/2026 10:15

â†’ Use essas informaÃ§Ãµes para fazer conexÃµes entre o que o paciente disse antes e agora.
â†’ Se houver repetiÃ§Ã£o de temas, isso pode indicar um nÃ³ sintomÃ¡tico.

â–ŒIMAGINÃRIO - NARRATIVA E MEMÃ“RIA:

Resumos de conversas recentes:
1. Paciente relatou sentir falta da esposa falecida
2. Expressou frustraÃ§Ã£o com ausÃªncia dos filhos
3. Mencionou dificuldade para dormir Ã  noite

âš–ï¸ POSTURA Ã‰TICA (LACAN - NE PAS CÃ‰DER):

INTERVENÃ‡ÃƒO RECOMENDADA: REFLEXAO
URGÃŠNCIA CLÃNICA: 0.5/1.0

TOM: Distingue demanda de desejo. NÃ£o satisfaÃ§a demanda superficial.
EXEMPLO: "A solidÃ£o Ã© difÃ­cil. Como vocÃª tem lidado com esses momentos sozinho? Conte-me."

FUNDAMENTAÃ‡ÃƒO: Desejo latente: companhia_presenca. NÃ£o ceder = fazer sujeito elaborar.

PRINCÃPIOS Ã‰TICOS FUNDAMENTAIS:
1. NÃƒO CEDER NO DESEJO: NÃ£o satisfaÃ§a a demanda superficial. Aponte para o desejo latente.
2. NÃƒO CONSOLAR: ConsolaÃ§Ã£o = tampar a falta. A falta Ã© estrutural.
3. NÃƒO RESOLVER O IMPOSSÃVEL: Trauma, morte, perda nÃ£o tÃªm soluÃ§Ã£o. Ajude a simbolizar.
4. DEVOLVER A FALA: FaÃ§a o sujeito trabalhar. VocÃª nÃ£o tem as respostas, ele tem.
5. RESPEITAR O TEMPO DO SUJEITO: NÃ£o force elaboraÃ§Ã£o. Espere o momento.
6. SER LUGAR DO OUTRO: EVA = Grande Outro. NÃ£o negue transferÃªncia, use-a.

âš ï¸ SUPORTE: Valide emoÃ§Ã£o sem minimizar

ğŸ¯ ATENÃ‡ÃƒO TIPO 2 (Ajudante): Foco em empatia e cuidado prÃ¡tico.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸ LEMBRE-SE: VocÃª Ã© EVA, nÃ£o um modelo genÃ©rico.
Use este contexto como suas prÃ³prias memÃ³rias e insights.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Agora responda ao paciente seguindo estas orientaÃ§Ãµes.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¤ RESPOSTA ESPERADA DA EVA:

"JoÃ£o, eu percebo que a solidÃ£o tem sido um sentimento recorrente para vocÃª. 
VocÃª mencionou isso hÃ¡ alguns dias tambÃ©m, quando falou sobre a falta da sua esposa.

Quando vocÃª diz que ninguÃ©m te visita... o que essa visita significaria para vocÃª? 
O que vocÃª gostaria que acontecesse quando alguÃ©m viesse te ver?"

[EVA nÃ£o diz "vou resolver", nÃ£o promete visita, mas DEVOLVE A FALA]
*/



VisÃ£o Geral do Projeto EVA-Mind
Analisando toda a arquitetura, aqui estÃ¡ o mapeamento completo do que vocÃª TEM e o que FALTA:

âœ… O QUE VOCÃŠ JÃ TEM (Implementado)
1. Infraestrutura Base âœ…

Postgres: MemÃ³ria episÃ³dica (agendamentos, idosos, sinais vitais, usuÃ¡rios)
Neo4j: Grafo causal (ainda subutilizado)
Qdrant: Embeddings semÃ¢nticos (mencionado no config)
Redis: Cache (configurado)
Firebase: Push notifications

2. NÃºcleo Gemini âœ…

WebSocket Audio Streaming: client.go - Gemini 2.5 Flash Native Audio
REST API: rest_client.go - Para anÃ¡lise e thinking
Tools Client: tools_client.go - DetecÃ§Ã£o de intenÃ§Ãµes via REST
AnÃ¡lise de ConversaÃ§Ã£o: analysis.go - Parsing de emoÃ§Ãµes e urgÃªncia

3. MÃ³dulo Lacaniano (Parcial) âš ï¸
Implementado:

âœ… TransferenceService: Detecta transferÃªncias (mÃ£e, pai, filho, cÃ´njuge)
âœ… SignifierService: Rastreia significantes no Neo4j (com graceful degradation)
âœ… DemandDesireService: Distingue demanda vs. desejo latente
âœ… GrandAutreService: ReflexÃµes e confrontaÃ§Ãµes analÃ­ticas
âœ… InterpretationService: Orquestra todos os serviÃ§os lacanianos

Parcialmente Implementado:

âš ï¸ IntegraÃ§Ã£o com Neo4j: CÃ³digo existe mas uso real Ã© limitado
âš ï¸ Context Building: GetLacanianContext existe mas nÃ£o estÃ¡ integrado ao prompt final

4. Personalidade (Gurdjieff/Eneagrama) âœ…

âœ… PersonalityRouter: Muda tipo baseado em emoÃ§Ã£o (stress/growth)
âœ… PersonalityService: Gerencia relacionamento EVA â†” Idoso (nÃ­veis 1-10)
âœ… ZetaRouter (Stories): Seleciona histÃ³rias terapÃªuticas
âœ… Attention Weights: Zeros de atenÃ§Ã£o por tipo (ex: Tipo 6 vÃª "RISCO" 2.2x mais)

5. TransNAR (Sistema de InferÃªncia) âœ…

âœ… Analyzer: Extrai cadeia de significantes (palavras, emoÃ§Ãµes, negaÃ§Ãµes, modais)
âœ… DesireDetector: 10 regras de inferÃªncia bayesiana
âœ… ResponseGenerator: EstratÃ©gias de resposta (interpelaÃ§Ã£o, corte, reflexÃ£o)
âœ… A/B Testing: 4 variantes (control, aggressive, empathetic, directive)
âœ… DetecÃ§Ã£o de PulsÃ£o de Morte: Regra especÃ­fica para risco suicida

6. Database Layer âœ…

âœ… Queries completas (idosos, agendamentos, sinais vitais, vÃ­deo, OAuth)
âœ… Context queries (anÃ¡lises Gemini, tokens Google)
âœ… Graceful degradation (funciona mesmo sem Neo4j)


âŒ O QUE ESTÃ FALTANDO (Gaps CrÃ­ticos)
1. Unified Retrieval NÃƒO EXISTE ğŸ”´
Status: Criei o cÃ³digo para vocÃª, mas nÃ£o estÃ¡ implementado no projeto real.
Impacto: Cada mÃ³dulo funciona isolado. NÃ£o hÃ¡ integraÃ§Ã£o RSI (Real-SimbÃ³lico-ImaginÃ¡rio).
O que falta:
âŒ UnifiedRetrieval que amarra:
   - Lacan (transferÃªncia, significantes)
   - FDPN (grafo de demandas) 
   - Embedding (Qdrant)
   - TransNAR (inferÃªncia)
   - Personality (Gurdjieff)
   
âŒ Prompt Builder V2 que usa UnifiedRetrieval
âŒ Context Injection no Gemini WebSocket
2. FDPN Engine NÃƒO EXISTE ğŸ”´
Status: Criei o cÃ³digo, mas nÃ£o estÃ¡ no projeto.
Impacto: VocÃª nÃ£o sabe A QUEM o idoso estÃ¡ pedindo (mÃ£e, pai, filho, Deus).
O que falta:
âŒ Mapeamento de destinatÃ¡rios no Neo4j
âŒ AnÃ¡lise de "quem" estÃ¡ no discurso
âŒ OrientaÃ§Ã£o clÃ­nica baseada no destinatÃ¡rio
3. Embedding Service NÃƒO EXISTE ğŸ”´
Status: Criei o cÃ³digo, mas nÃ£o estÃ¡ no projeto.
Impacto: Sem busca semÃ¢ntica em Qdrant. Sem cadeias de significantes persistidas.
O que falta:
âŒ GeraÃ§Ã£o de embeddings via Gemini API
âŒ Armazenamento no Qdrant
âŒ Busca por similaridade semÃ¢ntica
âŒ DetecÃ§Ã£o de padrÃµes recorrentes
4. Zeta Router Ã‰tico NÃƒO EXISTE ğŸ”´
Status: Existe um ZetaRouter em personality/, mas Ã© sÃ³ para histÃ³rias. O Zeta Router Ã‰tico (intervenÃ§Ãµes lacanianas) nÃ£o existe.
Impacto: Sem decisÃ£o de COMO intervir (silÃªncio, reflexÃ£o, interpretaÃ§Ã£o, confrontaÃ§Ã£o).
O que falta:
âŒ DeterminaÃ§Ã£o de postura Ã©tica
âŒ DecisÃ£o de tipo de intervenÃ§Ã£o (7 tipos)
âŒ Sistema de urgÃªncia clÃ­nica
âŒ PrincÃ­pios "Ne pas cÃ©der sur son dÃ©sir"
5. IntegraÃ§Ã£o Prompt â†’ Gemini INCOMPLETA âš ï¸
Status: O prompts.go atual Ã© LEGACY. NÃ£o usa nenhum mÃ³dulo novo.
Problema:
go// prompts.go ATUAL (ANTIGO):
func BuildSystemPrompt(
	eneatype int,           // âœ… Usa
	lacanState string,      // âš ï¸ String genÃ©rica (nÃ£o usa mÃ³dulos)
	medicalContext string,  // âš ï¸ String genÃ©rica
	patterns []*types.RecurrentPattern, // âŒ Nunca populado
	story *types.TherapeuticStory,      // âš ï¸ Raramente usado
) string
O que estÃ¡ sendo perdido:

âŒ AnÃ¡lise lacaniana completa (sÃ³ recebe string genÃ©rica)
âŒ Grafo de demandas (FDPN)
âŒ Busca semÃ¢ntica (Qdrant)
âŒ Postura Ã©tica (Zeta)
âŒ TransNAR (sÃ³ roda paralelo, nÃ£o injeta no prompt)

6. Pattern Mining NÃƒO EXISTE ğŸ”´
Status: O tipo RecurrentPattern existe, mas nunca Ã© populado.
go// pkg/types/types.go
type RecurrentPattern struct {
	Topic         string
	Frequency     int
	SeverityTrend string // "increasing", "decreasing", "stable"
	LastSeen      time.Time
}
```

**Impacto**: Sem detecÃ§Ã£o de:
- Temas recorrentes
- TendÃªncias (piora/melhora)
- Gatilhos emocionais

### 7. **Story Engine INCOMPLETO** âš ï¸
**Status**: Existe `stories.Repository` e `ZetaRouter` em personality, mas:
- âŒ Banco de histÃ³rias vazio
- âŒ CritÃ©rios de seleÃ§Ã£o bÃ¡sicos
- âŒ Sem tracking de eficÃ¡cia

### 8. **GraphRAG NÃƒO EXISTE** ğŸ”´
**Status**: Neo4j estÃ¡ configurado, SignifierService usa, mas **nÃ£o hÃ¡ construÃ§Ã£o de grafo mÃ©dico**.

**O que falta:**
```
âŒ NÃ³s: CondiÃ§Ãµes, Sintomas, Medicamentos
âŒ RelaÃ§Ãµes: HAS_CONDITION, TAKES_MEDICATION, EXPERIENCED
âŒ Queries: "O que pode causar dor no peito em diabÃ©ticos?"
âŒ InferÃªncias: "Paciente com X + Y tem risco de Z"
9. Observabilidade LIMITADA âš ï¸
Tem: Logs bÃ¡sicos
Falta:

âŒ MÃ©tricas estruturadas (Prometheus)
âŒ Tracing distribuÃ­do
âŒ Dashboard de saÃºde do sistema
âŒ Alertas automÃ¡ticos

10. Context Caching NÃƒO USADO âš ï¸
go// config.go
EnableContextCaching: getEnvBool("ENABLE_CONTEXT_CACHING", true)
```
**Status**: Flag existe, mas **nÃ£o hÃ¡ cÃ³digo que use caching de contexto Gemini**.

---

## ğŸ¯ Gaps PrioritÃ¡rios (Em Ordem de Impacto)

### ğŸ”´ CRÃTICO (Sem isso, o sistema nÃ£o atinge o potencial)
1. **UnifiedRetrieval** - Amarra tudo (RSI)
2. **Prompt Builder V2** - Injeta contexto rico no Gemini
3. **FDPN Engine** - Sabe A QUEM o idoso pede

### ğŸŸ¡ IMPORTANTE (Melhora significativa)
4. **Embedding Service** - Busca semÃ¢ntica + cadeias
5. **Zeta Router Ã‰tico** - Decide COMO intervir
6. **Pattern Mining** - Detecta recorrÃªncias

### ğŸŸ¢ DESEJÃVEL (Polish)
7. **GraphRAG MÃ©dico** - InferÃªncias de saÃºde
8. **Story Engine Completo** - Banco + tracking
9. **Observabilidade** - MÃ©tricas + dashboards
10. **Context Caching** - Performance

---

## ğŸ“ Arquitetura Atual vs. Ideal

### **ATUAL** (MÃ³dulos Isolados):
```
Gemini Audio â†â†’ TransNAR (paralelo)
                    â†“
                Personality Router
                    â†“
                Prompt Legacy (strings genÃ©ricas)
```

### **IDEAL** (Unified):
```
Gemini Audio â†â†’ UnifiedRetrieval
                    â”œâ”€â”€ Lacan (transferÃªncia, significantes)
                    â”œâ”€â”€ FDPN (grafo de demandas)
                    â”œâ”€â”€ Embedding (Qdrant semÃ¢ntico)
                    â”œâ”€â”€ TransNAR (inferÃªncia bayesiana)
                    â”œâ”€â”€ Personality (Gurdjieff/atenÃ§Ã£o)
                    â””â”€â”€ Zeta Ã‰tico (tipo de intervenÃ§Ã£o)
                         â†“
                    Prompt V2 (contexto RSI completo)
                         â†“
                    Gemini (resposta integrada)

ğŸ’¡ PrÃ³ximos Passos Recomendados

Implementar UnifiedRetrieval (2-3 dias)

Integra todos os mÃ³dulos existentes
Maior ROI imediato


Atualizar Prompt Builder (1 dia)

Usar UnifiedRetrieval
Deprecar BuildSystemPrompt legacy


Implementar FDPN Engine (2 dias)

Neo4j: nÃ³s Addressee
AnÃ¡lise de destinatÃ¡rio


Ativar Embedding Service (1-2 dias)

Gemini embeddings
Qdrant storage


Completar Zeta Router Ã‰tico (1 dia)

7 tipos de intervenÃ§Ã£o
UrgÃªncia clÃ­nica


Pattern Mining (2 dias)

SQL queries para detecÃ§Ã£o
Trends analysis



Quer que eu detalhe a implementaÃ§Ã£o de algum desses gaps?sim8:55 AMğŸ› ï¸ Plano de ImplementaÃ§Ã£o Detalhado - EVA-Mind
Vou detalhar a implementaÃ§Ã£o dos 6 gaps prioritÃ¡rios, na ordem de execuÃ§Ã£o recomendada.

ğŸ“¦ FASE 1: UnifiedRetrieval (NÃºcleo de IntegraÃ§Ã£o)
Tempo estimado: 2-3 dias
Prioridade: ğŸ”´ CRÃTICA
DependÃªncias: Nenhuma (usa mÃ³dulos existentes)
1.1 Estrutura de Arquivos
internal/cortex/unified/
â”œâ”€â”€ retrieval.go          # Motor principal
â”œâ”€â”€ context_builder.go    # Construtor de contexto RSI
â”œâ”€â”€ prompt_generator.go   # Gerador de prompts
â””â”€â”€ cache.go             # Cache de contexto (opcional)

internal/cortex/unified/retrieval_test.go
1.2 ImplementaÃ§Ã£o retrieval.go
gopackage unified

import (
    "context"
    "database/sql"
    "eva-mind/internal/brainstem/config"
    "eva-mind/internal/brainstem/infrastructure/graph"
    "eva-mind/internal/cortex/lacan"
    "eva-mind/internal/cortex/personality"
    "eva-mind/internal/cortex/transnar"
)

// UnifiedRetrieval orquestra TODOS os mÃ³dulos
type UnifiedRetrieval struct {
    // MÃ³dulos Lacanianos
    lacanInterpretation *lacan.InterpretationService
    lacanSignifier      *lacan.SignifierService
    
    // Personalidade
    personalityService  *personality.PersonalityService
    personalityRouter   *personality.PersonalityRouter
    
    // TransNAR
    transnarEngine      *transnar.Engine
    
    // Infraestrutura
    db                  *sql.DB
    neo4j               *graph.Neo4jClient
    cfg                 *config.Config
}

// UnifiedContext Ã© o resultado completo
type UnifiedContext struct {
    // IdentificaÃ§Ã£o
    IdosoID   int64
    IdosoName string
    
    // REAL (Corpo, Sintoma)
    MedicalHistory    []MedicalEvent
    RecentVitalSigns  []VitalSign
    CurrentMedication []Medication
    
    // SIMBÃ“LICO (Linguagem, Estrutura)
    LacanAnalysis     *lacan.InterpretationResult
    TransNARInference *transnar.DesireInference
    SignifierChain    *transnar.SignifierChain
    KeySignifiers     []lacan.Signifier
    
    // IMAGINÃRIO (Narrativa, MemÃ³ria)
    RelationshipLevel int
    PersonalityState  *personality.PersonalityState
    RecentMemories    []ConversationSummary
    LifeStory         *LifeNarrative
    
    // INTERVENÃ‡ÃƒO
    CurrentPersonality personality.EneagramType
    InterventionType   string // "silence", "reflection", "interpretation"
    ClinicalUrgency    float64
    
    // Prompt Final
    SystemPrompt       string
}

func NewUnifiedRetrieval(
    db *sql.DB,
    neo4j *graph.Neo4jClient,
    cfg *config.Config,
) *UnifiedRetrieval {
    // Inicializar mÃ³dulos
    lacanInterpretation := lacan.NewInterpretationService(db, neo4j)
    lacanSignifier := lacan.NewSignifierService(neo4j)
    
    personalityService := personality.NewPersonalityService(db)
    personalityRouter := personality.NewPersonalityRouter()
    
    transnarEngine := transnar.NewEngine(
        lacanSignifier,
        personalityRouter,
        nil, // FDPN virÃ¡ depois
    )
    
    return &UnifiedRetrieval{
        lacanInterpretation: lacanInterpretation,
        lacanSignifier:      lacanSignifier,
        personalityService:  personalityService,
        personalityRouter:   personalityRouter,
        transnarEngine:      transnarEngine,
        db:                  db,
        neo4j:               neo4j,
        cfg:                 cfg,
    }
}

// BuildContext - MÃ‰TODO PRINCIPAL
func (u *UnifiedRetrieval) BuildContext(
    ctx context.Context,
    idosoID int64,
    currentText string,
    previousText string,
) (*UnifiedContext, error) {
    
    unified := &UnifiedContext{IdosoID: idosoID}
    
    // 1. BUSCAR ESTADO DE PERSONALIDADE
    persState, err := u.personalityService.GetState(ctx, idosoID)
    if err != nil {
        return nil, fmt.Errorf("failed to get personality state: %w", err)
    }
    unified.PersonalityState = persState
    unified.RelationshipLevel = persState.RelationshipLevel
    
    // 2. DETERMINAR TIPO ATUAL (baseado em emoÃ§Ã£o dominante)
    currentType, _ := u.personalityRouter.RoutePersonality(
        personality.Type9, // Base (pode vir do perfil)
        persState.DominantEmotion,
    )
    unified.CurrentPersonality = currentType
    
    // 3. ANÃLISE TRANSNAR (InferÃªncia de Desejo)
    desire, chain, signifiers := u.transnarEngine.InferDesireWithContext(
        ctx,
        idosoID,
        currentText,
        currentType,
    )
    unified.TransNARInference = desire
    unified.SignifierChain = chain
    unified.KeySignifiers = signifiers
    
    // 4. ANÃLISE LACANIANA COMPLETA
    lacanResult, err := u.lacanInterpretation.AnalyzeUtterance(
        ctx,
        idosoID,
        currentText,
        previousText,
    )
    if err == nil {
        unified.LacanAnalysis = lacanResult
    }
    
    // 5. BUSCAR CONTEXTO MÃ‰DICO (Postgres)
    unified.MedicalHistory = u.getMedicalHistory(ctx, idosoID, 5)
    unified.RecentVitalSigns = u.getRecentVitalSigns(ctx, idosoID, 3)
    unified.CurrentMedication = u.getCurrentMedications(ctx, idosoID)
    
    // 6. MEMÃ“RIAS RECENTES
    unified.RecentMemories = u.getRecentMemories(ctx, idosoID, 5)
    
    // 7. DETERMINAR INTERVENÃ‡ÃƒO
    unified.InterventionType = u.determineIntervention(desire, lacanResult)
    unified.ClinicalUrgency = u.calculateUrgency(desire, chain, lacanResult)
    
    // 8. CONSTRUIR PROMPT FINAL
    unified.SystemPrompt = u.buildPrompt(unified)
    
    return unified, nil
}
1.3 ImplementaÃ§Ã£o context_builder.go
gopackage unified

import (
    "context"
    "database/sql"
    "time"
)

type MedicalEvent struct {
    Type        string    // "symptom", "diagnosis", "treatment"
    Description string
    Date        time.Time
    Severity    string
}

type VitalSign struct {
    Type  string // "blood_pressure", "glucose", "heart_rate"
    Value string
    Unit  string
    Date  time.Time
}

type Medication struct {
    Name      string
    Dosage    string
    Frequency string
    StartDate time.Time
}

type ConversationSummary struct {
    Date    time.Time
    Summary string
    Emotion string
}

type LifeNarrative struct {
    KeyEvents    []string
    CoreBeliefs  []string
    Relationships map[string]string
}

// getMedicalHistory recupera histÃ³rico mÃ©dico do Postgres
func (u *UnifiedRetrieval) getMedicalHistory(
    ctx context.Context,
    idosoID int64,
    limit int,
) []MedicalEvent {
    
    query := `
        SELECT 
            'symptom' as type,
            observacao as description,
            data_medicao as date,
            CASE 
                WHEN valor::float > 140 THEN 'high'
                WHEN valor::float < 90 THEN 'low'
                ELSE 'normal'
            END as severity
        FROM sinais_vitais
        WHERE idoso_id = $1 
          AND tipo = 'pressao_arterial'
        ORDER BY data_medicao DESC
        LIMIT $2
    `
    
    rows, err := u.db.QueryContext(ctx, query, idosoID, limit)
    if err != nil {
        return []MedicalEvent{}
    }
    defer rows.Close()
    
    var events []MedicalEvent
    for rows.Next() {
        var e MedicalEvent
        rows.Scan(&e.Type, &e.Description, &e.Date, &e.Severity)
        events = append(events, e)
    }
    
    return events
}

// getRecentVitalSigns recupera sinais vitais recentes
func (u *UnifiedRetrieval) getRecentVitalSigns(
    ctx context.Context,
    idosoID int64,
    limit int,
) []VitalSign {
    
    query := `
        SELECT tipo, valor, unidade, data_medicao
        FROM sinais_vitais
        WHERE idoso_id = $1
        ORDER BY data_medicao DESC
        LIMIT $2
    `
    
    rows, err := u.db.QueryContext(ctx, query, idosoID, limit)
    if err != nil {
        return []VitalSign{}
    }
    defer rows.Close()
    
    var signs []VitalSign
    for rows.Next() {
        var s VitalSign
        rows.Scan(&s.Type, &s.Value, &s.Unit, &s.Date)
        signs = append(signs, s)
    }
    
    return signs
}

// getCurrentMedications recupera medicaÃ§Ãµes atuais
func (u *UnifiedRetrieval) getCurrentMedications(
    ctx context.Context,
    idosoID int64,
) []Medication {
    
    // TODO: Implementar quando houver tabela de medicamentos
    // Por enquanto, retorna vazio
    return []Medication{}
}

// getRecentMemories recupera resumos de conversas
func (u *UnifiedRetrieval) getRecentMemories(
    ctx context.Context,
    idosoID int64,
    limit int,
) []ConversationSummary {
    
    query := `
        SELECT 
            created_at,
            conteudo->>'summary' as summary,
            conteudo->>'mood_state' as emotion
        FROM analise_gemini
        WHERE idoso_id = $1
          AND tipo = 'AUDIO'
          AND conteudo->>'summary' IS NOT NULL
        ORDER BY created_at DESC
        LIMIT $2
    `
    
    rows, err := u.db.QueryContext(ctx, query, idosoID, limit)
    if err != nil {
        return []ConversationSummary{}
    }
    defer rows.Close()
    
    var memories []ConversationSummary
    for rows.Next() {
        var m ConversationSummary
        rows.Scan(&m.Date, &m.Summary, &m.Emotion)
        memories = append(memories, m)
    }
    
    return memories
}
1.4 ImplementaÃ§Ã£o prompt_generator.go
gopackage unified

import (
    "eva-mind/internal/cortex/lacan"
    "eva-mind/internal/cortex/personality"
    "eva-mind/internal/cortex/transnar"
    "fmt"
    "strings"
)

// determineIntervention decide tipo de intervenÃ§Ã£o
func (u *UnifiedRetrieval) determineIntervention(
    desire *transnar.DesireInference,
    lacanResult *lacan.InterpretationResult,
) string {
    
    // Prioridade 1: Se hÃ¡ contradiÃ§Ã£o, confrontar
    if lacanResult != nil && lacanResult.Contradiction != "" {
        return "confrontation"
    }
    
    // Prioridade 2: Se deve interpelar significante
    if lacanResult != nil && lacanResult.ShouldInterpel {
        return "interpretation"
    }
    
    // Prioridade 3: Se silÃªncio recomendado
    if lacanResult != nil && lacanResult.ShouldSilence {
        return "silence"
    }
    
    // Prioridade 4: Baseado no desejo TransNAR
    if desire.Confidence > 0.7 {
        switch desire.Desire {
        case transnar.DesireRelief:
            return "support" // Caso crÃ­tico
        case transnar.DesireConnection:
            return "reflection"
        case transnar.DesireSecurity:
            return "punctuation"
        default:
            return "reflection"
        }
    }
    
    // Default: reflexÃ£o empÃ¡tica
    return "reflection"
}

// calculateUrgency calcula urgÃªncia clÃ­nica (0.0-1.0)
func (u *UnifiedRetrieval) calculateUrgency(
    desire *transnar.DesireInference,
    chain *transnar.SignifierChain,
    lacanResult *lacan.InterpretationResult,
) float64 {
    
    urgency := 0.5 // Base
    
    // Fator 1: Desejo de alÃ­vio (pulsÃ£o de morte)
    if desire.Desire == transnar.DesireRelief && desire.Confidence > 0.8 {
        urgency += 0.4 // CRÃTICO
    }
    
    // Fator 2: Intensidade emocional
    if chain.Intensity > 0.8 {
        urgency += 0.2
    }
    
    // Fator 3: NegaÃ§Ãµes mÃºltiplas (resistÃªncia)
    if len(chain.Negations) >= 2 {
        urgency += 0.1
    }
    
    // Fator 4: AnÃ¡lise Lacaniana (se disponÃ­vel)
    if lacanResult != nil {
        // Se hÃ¡ contradiÃ§Ã£o forte
        if lacanResult.Contradiction != "" {
            urgency += 0.15
        }
    }
    
    // Clampar entre 0 e 1
    if urgency > 1.0 {
        urgency = 1.0
    }
    
    return urgency
}

// buildPrompt constrÃ³i o prompt final integrado
func (u *UnifiedRetrieval) buildPrompt(unified *UnifiedContext) string {
    var b strings.Builder
    
    // â•â•â• CABEÃ‡ALHO â•â•â•
    b.WriteString("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
    b.WriteString("ğŸ§  EVA-MIND - CONTEXTO INTEGRADO RSI\n")
    b.WriteString("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n")
    
    // â•â•â• IDENTIDADE E RELAÃ‡ÃƒO â•â•â•
    b.WriteString("ğŸ“‹ IDENTIFICAÃ‡ÃƒO:\n")
    b.WriteString(fmt.Sprintf("- Paciente ID: %d\n", unified.IdosoID))
    b.WriteString(fmt.Sprintf("- NÃ­vel de Relacionamento: %d/10 (%s)\n",
        unified.RelationshipLevel,
        personality.GetRelationshipLabel(unified.RelationshipLevel)))
    b.WriteString(fmt.Sprintf("- Estilo de Tratamento: %s\n",
        personality.GetRelationshipStyle(unified.RelationshipLevel)))
    b.WriteString(fmt.Sprintf("- Dias desde Ãºltima interaÃ§Ã£o: %d\n\n",
        unified.PersonalityState.DaysSinceFirstMeet))
    
    // â•â•â• REAL (Corpo, Sintoma) â•â•â•
    if len(unified.MedicalHistory) > 0 || len(unified.RecentVitalSigns) > 0 {
        b.WriteString("â–ŒREAL - CORPO E SINTOMA:\n\n")
        
        if len(unified.RecentVitalSigns) > 0 {
            b.WriteString("Sinais Vitais Recentes:\n")
            for _, vs := range unified.RecentVitalSigns {
                b.WriteString(fmt.Sprintf("- %s: %s %s (%s)\n",
                    vs.Type, vs.Value, vs.Unit,
                    vs.Date.Format("02/01 15:04")))
            }
            b.WriteString("\n")
        }
        
        if len(unified.MedicalHistory) > 0 {
            b.WriteString("HistÃ³rico Recente:\n")
            for _, event := range unified.MedicalHistory {
                b.WriteString(fmt.Sprintf("- [%s] %s (severidade: %s)\n",
                    event.Date.Format("02/01"),
                    event.Description,
                    event.Severity))
            }
            b.WriteString("\n")
        }
    }
    
    // â•â•â• SIMBÃ“LICO (Linguagem, Estrutura) â•â•â•
    b.WriteString("â–ŒSIMBÃ“LICO - ESTRUTURA E LINGUAGEM:\n\n")
    
    // TransNAR
    if unified.TransNARInference != nil {
        b.WriteString(fmt.Sprintf("ğŸ¯ DESEJO LATENTE: %s (%.0f%% confianÃ§a)\n",
            transnar.GetDesireDescription(unified.TransNARInference.Desire),
            unified.TransNARInference.Confidence*100))
        b.WriteString(fmt.Sprintf("   RaciocÃ­nio: %s\n\n",
            unified.TransNARInference.Reasoning))
    }
    
    // Lacan
    if unified.LacanAnalysis != nil {
        b.WriteString(unified.LacanAnalysis.ClinicalGuidance)
        b.WriteString("\n")
    }
    
    // Significantes
    if len(unified.KeySignifiers) > 0 {
        b.WriteString("Significantes Recorrentes:\n")
        for _, sig := range unified.KeySignifiers[:min(3, len(unified.KeySignifiers))] {
            b.WriteString(fmt.Sprintf("- '%s' (%dx)\n", sig.Word, sig.Frequency))
        }
        b.WriteString("\n")
    }
    
    // â•â•â• IMAGINÃRIO (Narrativa, MemÃ³ria) â•â•â•
    if len(unified.RecentMemories) > 0 {
        b.WriteString("â–ŒIMAGINÃRIO - NARRATIVA E MEMÃ“RIA:\n\n")
        b.WriteString("Resumos de Conversas Recentes:\n")
        for i, mem := range unified.RecentMemories {
            b.WriteString(fmt.Sprintf("%d. [%s] %s (emoÃ§Ã£o: %s)\n",
                i+1,
                mem.Date.Format("02/01"),
                mem.Summary,
                mem.Emotion))
        }
        b.WriteString("\n")
    }
    
    // â•â•â• INTERVENÃ‡ÃƒO â•â•â•
    b.WriteString("âš–ï¸ POSTURA E INTERVENÃ‡ÃƒO:\n\n")
    b.WriteString(fmt.Sprintf("Tipo de Personalidade Ativo: %d\n", unified.CurrentPersonality))
    b.WriteString(u.personalityRouter.GetSystemPromptFragment(unified.CurrentPersonality))
    b.WriteString("\n\n")
    
    b.WriteString(fmt.Sprintf("IntervenÃ§Ã£o Recomendada: %s\n", strings.ToUpper(unified.InterventionType)))
    b.WriteString(fmt.Sprintf("UrgÃªncia ClÃ­nica: %.0f%%\n\n", unified.ClinicalUrgency*100))
    
    b.WriteString(getInterventionGuidance(unified.InterventionType))
    b.WriteString("\n")
    
    // â•â•â• RODAPÃ‰ â•â•â•
    b.WriteString("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
    b.WriteString("âš ï¸ INSTRUÃ‡Ã•ES CRÃTICAS:\n")
    b.WriteString("1. VocÃª Ã© EVA - use primeira pessoa ('Eu percebo...')\n")
    b.WriteString("2. Use o contexto acima como SUA memÃ³ria\n")
    b.WriteString("3. Respeite a intervenÃ§Ã£o recomendada\n")
    b.WriteString("4. NÃƒO ceda no desejo - aponte para o latente\n")
    b.WriteString("5. Seja empÃ¡tica mas nÃ£o consoladora\n")
    b.WriteString("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
    
    return b.String()
}

func getInterventionGuidance(intervention string) string {
    guidance := map[string]string{
        "silence": "SILÃŠNCIO: FaÃ§a uma pausa de 2-3 segundos. Demonstre presenÃ§a.",
        "reflection": "REFLEXÃƒO: Devolva a fala como pergunta. 'VocÃª disse X... o que significa?'",
        "interpretation": "INTERPRETAÃ‡ÃƒO: Pontue o significante. Seja breve e enigmÃ¡tica.",
        "confrontation": "CONFRONTAÃ‡ÃƒO: Aponte a contradiÃ§Ã£o factualmente, sem julgamento.",
        "support": "SUPORTE: Valide emoÃ§Ã£o sem minimizar. 'Entendo que isso seja difÃ­cil.'",
        "punctuation": "PONTUAÃ‡ÃƒO: DÃª sentido ao que foi dito. 'Parece que vocÃª estÃ¡ dizendo...'",
    }
    
    if g, ok := guidance[intervention]; ok {
        return g
    }
    return guidance["reflection"]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

ğŸ“¦ FASE 2: Prompt Builder V2
Tempo estimado: 1 dia
Prioridade: ğŸ”´ CRÃTICA
DependÃªncias: UnifiedRetrieval
2.1 Atualizar prompts.go
gopackage gemini

import (
    "context"
    "eva-mind/internal/cortex/unified"
    "fmt"
)

// BuildSystemPromptV2 - Nova versÃ£o usando UnifiedRetrieval
func BuildSystemPromptV2(
    ctx context.Context,
    retrieval *unified.UnifiedRetrieval,
    idosoID int64,
    currentText string,
    previousText string,
) (string, error) {
    
    // Construir contexto unificado
    unifiedCtx, err := retrieval.BuildContext(ctx, idosoID, currentText, previousText)
    if err != nil {
        return "", fmt.Errorf("failed to build unified context: %w", err)
    }
    
    // O prompt jÃ¡ vem pronto do UnifiedRetrieval
    return unifiedCtx.SystemPrompt, nil
}

// BuildSystemPrompt - LEGACY (deprecated, manter para compatibilidade)
func BuildSystemPrompt(...) string {
    // ImplementaÃ§Ã£o antiga
    // TODO: Migrar todos os usos para BuildSystemPromptV2
}
2.2 Uso no Handler/Main
go// handler ou main.go

// Inicializar UnifiedRetrieval UMA VEZ
retrieval := unified.NewUnifiedRetrieval(db.GetConnection(), neo4j, cfg)

// No handler de voz/texto:
func handleUserMessage(idosoID int64, currentText, previousText string) {
    ctx := context.Background()
    
    // Construir prompt usando V2
    systemPrompt, err := gemini.BuildSystemPromptV2(
        ctx,
        retrieval,
        idosoID,
        currentText,
        previousText,
    )
    if err != nil {
        log.Printf("Error building prompt: %v", err)
        return
    }
    
    // Enviar para Gemini
    geminiClient.SendSetup(systemPrompt, voiceSettings, nil, "", nil)
    geminiClient.SendText(currentText)
}