<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVA Voice Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #fff;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }

        .container {
            background-color: #2d2d2d;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 600px;
            text-align: center;
        }

        h1 {
            margin-bottom: 10px;
            color: #00d4ff;
        }

        .subtitle {
            color: #888;
            margin-bottom: 30px;
        }

        .status-dot {
            height: 12px;
            width: 12px;
            background-color: #555;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .status-dot.connected {
            background-color: #00ff88;
            box-shadow: 0 0 10px #00ff88;
        }

        .status-dot.error {
            background-color: #ff4444;
        }

        .status-dot.listening {
            background-color: #00d4ff;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 212, 255, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(0, 212, 255, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(0, 212, 255, 0);
            }
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #btnConnect {
            background-color: #00ff88;
            color: #000;
        }

        #btnDisconnect {
            background-color: #ff4444;
            color: #fff;
        }

        .log-container {
            background-color: #111;
            border-radius: 8px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            text-align: left;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            border: 1px solid #444;
        }

        .log-entry {
            margin-bottom: 4px;
            border-bottom: 1px solid #222;
            padding-bottom: 2px;
        }

        .log-entry.sent {
            color: #00ff88;
        }

        .log-entry.received {
            color: #00d4ff;
        }

        .log-entry.error {
            color: #ff4444;
        }

        .log-entry.info {
            color: #888;
        }

        .info-panel {
            display: flex;
            justify-content: space-between;
            background: #222;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        input {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            width: 120px;
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>EVA Voice Test</h1>
        <div class="subtitle">WebSocket PCM Interface Tester</div>

        <div class="info-panel">
            <div>
                <label>CPF:</label>
                <input type="text" id="cpfInput" value="64525430249">
            </div>
            <div>
                <label>Status:</label>
                <span id="statusText">Disconnected</span>
                <span id="statusDot" class="status-dot"></span>
            </div>
        </div>

        <div class="controls">
            <button id="btnConnect" onclick="startCall()">ðŸ“ž Iniciar Chamada</button>
            <button id="btnDisconnect" onclick="endCall()" disabled>ðŸ›‘ Desligar</button>
        </div>

        <div class="log-container" id="logContainer">
            <div class="log-entry info">System ready. waiting for user...</div>
        </div>
    </div>

    <script>
        // CONFIG
        const WS_URL = "ws://104.248.219.200:8090/ws/pcm";
        const SAMPLE_RATE = 24000;

        // STATE
        let ws = null;
        let audioContext = null;
        let audioWorkletNode = null;
        let sourceNode = null;
        let isConnected = false;
        let nextStartTime = 0;

        // DOM Elements
        const btnConnect = document.getElementById('btnConnect');
        const btnDisconnect = document.getElementById('btnDisconnect');
        const logContainer = document.getElementById('logContainer');
        const statusText = document.getElementById('statusText');
        const statusDot = document.getElementById('statusDot');
        const cpfInput = document.getElementById('cpfInput');

        function log(msg, type = 'info') {
            const div = document.createElement('div');
            div.className = `log-entry ${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logContainer.appendChild(div);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        async function startCall() {
            const cpf = cpfInput.value;
            if (!cpf) return alert("CPF Required");

            try {
                // 0. Check Secure Context
                if (!window.isSecureContext && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                    throw new Error("Microphone requires HTTPS or localhost. Current origin is insecure.");
                }

                // 1. Init Audio Context
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: SAMPLE_RATE,
                });

                log(`AudioContext created at ${audioContext.sampleRate}Hz`, 'info');

                // 2. Load Microphone (Polyfill for robustness)
                if (!navigator.mediaDevices) {
                    navigator.mediaDevices = {};
                }
                if (!navigator.mediaDevices.getUserMedia) {
                    navigator.mediaDevices.getUserMedia = function (constraints) {
                        const getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
                        if (!getUserMedia) {
                            return Promise.reject(new Error('getUserMedia is not implemented in this browser'));
                        }
                        return new Promise(function (resolve, reject) {
                            getUserMedia.call(navigator, constraints, resolve, reject);
                        });
                    }
                }

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: SAMPLE_RATE,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                log('Microphone access granted', 'info');

                // 3. Setup Audio Worklet for Recording
                await audioContext.audioWorklet.addModule('pcm-processor.js');
                sourceNode = audioContext.createMediaStreamSource(stream);
                audioWorkletNode = new AudioWorkletNode(audioContext, 'pcm-processor');

                audioWorkletNode.port.onmessage = (event) => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        // Send PCM16 data to Server
                        ws.send(event.data);
                    }
                };

                sourceNode.connect(audioWorkletNode);
                audioWorkletNode.connect(audioContext.destination); // Connect to output specifically for processing clock, but we mute it or process sends silence usually. Actually standard practice is connect to destination to keep it alive, but verify if pcm-processor passes through. Usually processors output nothing if they just record.

                // 4. Connect WebSocket
                connectWebSocket(cpf);

            } catch (e) {
                log(`Error starting call: ${e.message}`, 'error');
                console.error(e);
            }
        }

        function connectWebSocket(cpf) {
            log(`Connecting to ${WS_URL}...`, 'info');
            ws = new WebSocket(WS_URL);
            ws.binaryType = 'arraybuffer';

            ws.onopen = () => {
                log('WebSocket Connected', 'sent');
                isConnected = true;
                updateUI(true);

                // Handshake
                const registerMsg = { type: 'register', cpf: cpf };
                ws.send(JSON.stringify(registerMsg));
                log(`Sent Register: ${JSON.stringify(registerMsg)}`, 'sent');

                setTimeout(() => {
                    const sessionId = `web-${Date.now()}`;
                    const startMsg = { type: 'start_call', cpf: cpf, session_id: sessionId };
                    ws.send(JSON.stringify(startMsg));
                    log(`Sent Start Call: ${JSON.stringify(startMsg)}`, 'sent');
                }, 500);
            };

            ws.onmessage = (event) => {
                if (typeof event.data === 'string') {
                    // JSON Control Message
                    log(`RCVD: ${event.data}`, 'received');
                } else {
                    // Binary Audio Data
                    playPcmChunk(event.data);
                }
            };

            ws.onerror = (e) => {
                log('WebSocket Error', 'error');
                updateUI(false);
            };

            ws.onclose = () => {
                log('WebSocket Closed', 'info');
                endCall();
            };
        }

        function playPcmChunk(arrayBuffer) {
            if (!audioContext) return;

            // Convert PCM16 (ArrayBuffer) to Float32
            const int16Array = new Int16Array(arrayBuffer);
            const float32Array = new Float32Array(int16Array.length);

            for (let i = 0; i < int16Array.length; i++) {
                // Normalize 16-bit signed integer to [-1.0, 1.0]
                float32Array[i] = int16Array[i] / 32768; // 0x8000
            }

            // Create AudioBuffer
            const audioBuffer = audioContext.createBuffer(1, float32Array.length, SAMPLE_RATE);
            audioBuffer.getChannelData(0).set(float32Array);

            // Schedule Playback
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);

            // Time scheduling for gapless playback
            const currentTime = audioContext.currentTime;
            if (nextStartTime < currentTime) {
                nextStartTime = currentTime;
            }

            source.start(nextStartTime);
            nextStartTime += audioBuffer.duration;
        }

        function endCall() {
            isConnected = false;
            updateUI(false);

            if (ws) {
                ws.close();
                ws = null;
            }

            if (audioWorkletNode) {
                audioWorkletNode.disconnect();
                audioWorkletNode = null;
            }

            if (sourceNode) {
                sourceNode.disconnect();
                sourceNode = null;
            }

            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            log('Call Ended', 'info');
        }

        function updateUI(connected) {
            btnConnect.disabled = connected;
            btnDisconnect.disabled = !connected;
            statusText.textContent = connected ? "Connected & Listening" : "Disconnected";
            statusDot.className = `status-dot ${connected ? 'connected listening' : 'error'}`;
            cpfInput.disabled = connected;
        }
    </script>
</body>

</html>